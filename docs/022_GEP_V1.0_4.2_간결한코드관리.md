# GEP V1.0 간결한 코드 관리

## 📋 개요
**General Exam Platform (GEP) V1.0** - 간결한 코드 관리 및 유지보수 전략
**기준**: ACIU S4 검증된 코드 관리 경험 + 간결성 원칙
**목표**: 유지보수 용이하고 확장 가능한 코드베이스 구축

---

## 🎯 핵심 코드 관리 원칙

### **간결성 우선 원칙**
- **파일 크기 제한**: 각 파일은 명확한 목적과 적절한 크기 유지
- **함수 단일 책임**: 각 함수는 하나의 명확한 목적만 수행
- **코드 중복 최소화**: 재사용 가능한 모듈과 유틸리티 함수 활용
- **가독성 최우선**: 복잡한 로직보다 직관적이고 이해하기 쉬운 코드

### **ACIU S4 검증된 코드 관리 패턴**
- **모듈화 전략**: 기능별로 명확히 분리된 모듈 구조
- **의존성 최소화**: 모듈 간 결합도 낮추고 응집도 높이기
- **표준화된 구조**: 일관된 파일 구조와 명명 규칙
- **자동화된 검증**: 코드 품질 자동 검증 시스템

---

## 📁 파일 구조 관리

### **1. 파일 크기 제한 및 관리**

#### **파일 크기 가이드라인**
```javascript
// 파일 크기 제한 규칙
const fileSizeGuidelines = {
    // Python 파일
    'app.py': { maxLines: 200, description: '메인 애플리케이션' },
    'services/*.py': { maxLines: 200, description: '비즈니스 로직 서비스' },
    'routes/*.py': { maxLines: 150, description: 'API 라우트' },
    'models/*.py': { maxLines: 150, description: '데이터 모델' },
    'utils/*.py': { maxLines: 100, description: '유틸리티 함수' },
    'config/*.py': { maxLines: 50, description: '설정 파일' },
    
    // JavaScript 파일
    'static/js/app.js': { maxLines: 200, description: '메인 JavaScript' },
    'static/js/services/*.js': { maxLines: 200, description: '프론트엔드 서비스' },
    'static/js/components/*.js': { maxLines: 150, description: 'UI 컴포넌트' },
    'static/js/utils/*.js': { maxLines: 100, description: '유틸리티 함수' },
    
    // CSS 파일
    'static/css/main.css': { maxLines: 200, description: '메인 스타일' },
    'static/css/components/*.css': { maxLines: 150, description: '컴포넌트 스타일' },
    'static/css/mobile.css': { maxLines: 150, description: '모바일 스타일' }
};
```

#### **파일 크기 자동 검증 시스템**
```javascript
class FileSizeValidator {
    // 파일 크기 검증
    static validateFileSize(filePath) {
        const guidelines = fileSizeGuidelines;
        const fileExtension = this.getFileExtension(filePath);
        const maxLines = this.getMaxLines(filePath, guidelines);
        
        const lineCount = this.countLines(filePath);
        const isWithinLimit = lineCount <= maxLines;
        
        return {
            filePath: filePath,
            lineCount: lineCount,
            maxLines: maxLines,
            isWithinLimit: isWithinLimit,
            status: isWithinLimit ? 'PASS' : 'EXCEEDED',
            recommendation: this.generateRecommendation(lineCount, maxLines, filePath)
        };
    }
    
    // 파일 분할 권장사항 생성
    static generateRecommendation(lineCount, maxLines, filePath) {
        if (lineCount <= maxLines) {
            return '적절한 크기입니다.';
        }
        
        const excessLines = lineCount - maxLines;
        const suggestedFiles = Math.ceil(lineCount / maxLines);
        
        return {
            action: 'FILE_SPLIT',
            reason: `파일이 ${excessLines}줄 초과했습니다.`,
            suggestion: `${suggestedFiles}개 파일로 분할을 권장합니다.`,
            splitStrategy: this.generateSplitStrategy(filePath, lineCount)
        };
    }
    
    // 파일 분할 전략 생성
    static generateSplitStrategy(filePath, lineCount) {
        const fileType = this.getFileType(filePath);
        
        switch (fileType) {
            case 'service':
                return {
                    'main-service.py': '핵심 서비스 로직',
                    'helper-functions.py': '헬퍼 함수들',
                    'data-processors.py': '데이터 처리 함수들'
                };
            case 'route':
                return {
                    'main-routes.py': '주요 라우트',
                    'auth-routes.py': '인증 관련 라우트',
                    'api-routes.py': 'API 라우트'
                };
            case 'component':
                return {
                    'main-component.js': '메인 컴포넌트',
                    'sub-components.js': '하위 컴포넌트들',
                    'utilities.js': '유틸리티 함수들'
                };
            default:
                return {
                    'part1': '첫 번째 부분',
                    'part2': '두 번째 부분',
                    'part3': '세 번째 부분'
                };
        }
    }
}
```

### **2. 폴더 구조 표준화**

#### **표준 폴더 구조**
```
GEP_V1.0/
├── 📱 app.py                    # 메인 애플리케이션 (200줄 이하)
├── 📊 database/                 # 데이터베이스 관련
│   ├── __init__.py
│   ├── models.py               # 데이터 모델 (150줄 이하)
│   ├── migrations.py           # 데이터 마이그레이션 (100줄 이하)
│   └── gep_master.db           # SQLite 데이터베이스
├── 🔧 services/                 # 비즈니스 로직 서비스
│   ├── __init__.py
│   ├── question_service.py     # 문제 관리 서비스 (200줄 이하)
│   ├── user_service.py         # 사용자 관리 서비스 (200줄 이하)
│   ├── stats_service.py        # 통계 관리 서비스 (200줄 이하)
│   └── payment_service.py      # 결제 관리 서비스 (150줄 이하)
├── 🌐 routes/                   # API 라우트
│   ├── __init__.py
│   ├── question_routes.py      # 문제 관련 API (150줄 이하)
│   ├── user_routes.py          # 사용자 관련 API (150줄 이하)
│   ├── stats_routes.py         # 통계 관련 API (150줄 이하)
│   └── payment_routes.py       # 결제 관련 API (100줄 이하)
├── 🎨 templates/                # HTML 템플릿
│   ├── base.html               # 기본 템플릿 (100줄 이하)
│   ├── home.html               # 메인 페이지 (150줄 이하)
│   ├── question.html           # 문제 풀이 페이지 (200줄 이하)
│   ├── statistics.html         # 통계 페이지 (200줄 이하)
│   └── settings.html           # 설정 페이지 (150줄 이하)
├── 🎯 static/                   # 정적 파일
│   ├── css/
│   │   ├── main.css            # 메인 스타일 (200줄 이하)
│   │   ├── mobile.css          # 모바일 스타일 (150줄 이하)
│   │   └── components.css      # 컴포넌트 스타일 (100줄 이하)
│   ├── js/
│   │   ├── app.js              # 메인 JavaScript (200줄 이하)
│   │   ├── question.js         # 문제 풀이 로직 (200줄 이하)
│   │   ├── stats.js            # 통계 로직 (150줄 이하)
│   │   └── utils.js            # 유틸리티 함수 (100줄 이하)
│   └── images/
│       ├── logo.png
│       └── icons/
├── 📚 data/                     # 데이터 파일
│   ├── gep_master.xlsx         # 기존 GEP 마스터 데이터
│   ├── questions.json          # 변환된 문제 데이터
│   └── user_data/              # 사용자 데이터 폴더
├── 🧪 tests/                    # 테스트 파일
│   ├── __init__.py
│   ├── test_services.py        # 서비스 테스트 (150줄 이하)
│   ├── test_routes.py          # 라우트 테스트 (150줄 이하)
│   └── test_utils.py           # 유틸리티 테스트 (100줄 이하)
├── 🔧 utils/                    # 유틸리티 함수
│   ├── __init__.py
│   ├── data_converter.py       # 데이터 변환 유틸 (150줄 이하)
│   ├── auth_utils.py           # 인증 유틸리티 (100줄 이하)
│   └── validation.py           # 데이터 검증 (100줄 이하)
├── ⚙️ config/                   # 설정 파일
│   ├── __init__.py
│   ├── settings.py             # 기본 설정 (100줄 이하)
│   ├── database.py             # 데이터베이스 설정 (50줄 이하)
│   └── services.py             # 서비스 설정 (50줄 이하)
└── 📖 docs/                     # 문서
    ├── api_docs.md             # API 문서
    ├── setup_guide.md          # 설치 가이드
    └── development_guide.md    # 개발 가이드
```

#### **폴더 구조 검증 시스템**
```javascript
class FolderStructureValidator {
    // 폴더 구조 검증
    static validateFolderStructure(projectPath) {
        const expectedStructure = this.getExpectedStructure();
        const actualStructure = this.scanProjectStructure(projectPath);
        
        const validationResults = {
            missingFolders: [],
            extraFolders: [],
            fileCounts: {},
            recommendations: []
        };
        
        // 누락된 폴더 확인
        for (const folder of expectedStructure.folders) {
            if (!actualStructure.folders.includes(folder)) {
                validationResults.missingFolders.push(folder);
            }
        }
        
        // 파일 개수 확인
        for (const [folder, expectedCount] of Object.entries(expectedStructure.fileCounts)) {
            const actualCount = actualStructure.fileCounts[folder] || 0;
            validationResults.fileCounts[folder] = {
                expected: expectedCount,
                actual: actualCount,
                status: actualCount >= expectedCount ? 'SUFFICIENT' : 'INSUFFICIENT'
            };
        }
        
        // 권장사항 생성
        validationResults.recommendations = this.generateRecommendations(validationResults);
        
        return validationResults;
    }
    
    // 권장사항 생성
    static generateRecommendations(results) {
        const recommendations = [];
        
        if (results.missingFolders.length > 0) {
            recommendations.push({
                type: 'CREATE_FOLDERS',
                folders: results.missingFolders,
                reason: '표준 폴더 구조에 필요한 폴더가 누락되었습니다.'
            });
        }
        
        for (const [folder, countInfo] of Object.entries(results.fileCounts)) {
            if (countInfo.status === 'INSUFFICIENT') {
                recommendations.push({
                    type: 'ADD_FILES',
                    folder: folder,
                    needed: countInfo.expected - countInfo.actual,
                    reason: `${folder} 폴더에 파일이 부족합니다.`
                });
            }
        }
        
        return recommendations;
    }
}
```

---

## 🔧 함수 관리

### **1. 함수 크기 및 복잡도 관리**

#### **함수 크기 가이드라인**
```javascript
// 함수 크기 제한 규칙
const functionSizeGuidelines = {
    // Python 함수
    'main': { maxLines: 50, description: '메인 함수' },
    'service': { maxLines: 30, description: '서비스 함수' },
    'route': { maxLines: 25, description: '라우트 함수' },
    'utility': { maxLines: 20, description: '유틸리티 함수' },
    'test': { maxLines: 25, description: '테스트 함수' },
    
    // JavaScript 함수
    'component': { maxLines: 40, description: '컴포넌트 함수' },
    'event_handler': { maxLines: 25, description: '이벤트 핸들러' },
    'api_call': { maxLines: 20, description: 'API 호출 함수' },
    'formatter': { maxLines: 15, description: '포맷터 함수' }
};
```

#### **함수 복잡도 관리**
```javascript
class FunctionComplexityManager {
    // 함수 복잡도 분석
    static analyzeFunctionComplexity(functionCode) {
        const analysis = {
            cyclomaticComplexity: this.calculateCyclomaticComplexity(functionCode),
            cognitiveComplexity: this.calculateCognitiveComplexity(functionCode),
            nestingDepth: this.calculateNestingDepth(functionCode),
            parameterCount: this.countParameters(functionCode),
            lineCount: this.countLines(functionCode)
        };
        
        analysis.overallScore = this.calculateOverallScore(analysis);
        analysis.recommendations = this.generateComplexityRecommendations(analysis);
        
        return analysis;
    }
    
    // 순환 복잡도 계산
    static calculateCyclomaticComplexity(code) {
        const complexityFactors = [
            /if\s*\(/g,           // if 문
            /else\s*if\s*\(/g,    // else if 문
            /for\s*\(/g,          // for 루프
            /while\s*\(/g,        // while 루프
            /case\s+/g,           // case 문
            /catch\s*\(/g,        // catch 블록
            /&&/g,                // AND 연산자
            /\|\|/g               // OR 연산자
        ];
        
        let complexity = 1; // 기본 복잡도
        
        for (const factor of complexityFactors) {
            const matches = code.match(factor);
            if (matches) {
                complexity += matches.length;
            }
        }
        
        return complexity;
    }
    
    // 복잡도 권장사항 생성
    static generateComplexityRecommendations(analysis) {
        const recommendations = [];
        
        if (analysis.cyclomaticComplexity > 10) {
            recommendations.push({
                type: 'REDUCE_CYCLOMATIC_COMPLEXITY',
                reason: '순환 복잡도가 너무 높습니다.',
                suggestion: '함수를 더 작은 단위로 분할하세요.',
                target: '10 이하'
            });
        }
        
        if (analysis.nestingDepth > 4) {
            recommendations.push({
                type: 'REDUCE_NESTING_DEPTH',
                reason: '중첩 깊이가 너무 깊습니다.',
                suggestion: 'early return 패턴을 사용하세요.',
                target: '4 이하'
            });
        }
        
        if (analysis.parameterCount > 5) {
            recommendations.push({
                type: 'REDUCE_PARAMETERS',
                reason: '매개변수가 너무 많습니다.',
                suggestion: '객체나 설정 객체를 사용하세요.',
                target: '5 이하'
            });
        }
        
        return recommendations;
    }
}
```

### **2. 함수 분할 전략**

#### **함수 분할 가이드라인**
```javascript
class FunctionSplitter {
    // 함수 분할 필요성 판단
    static shouldSplitFunction(functionCode) {
        const analysis = FunctionComplexityManager.analyzeFunctionComplexity(functionCode);
        
        return {
            shouldSplit: analysis.overallScore < 70,
            reasons: analysis.recommendations,
            splitStrategy: this.generateSplitStrategy(functionCode, analysis)
        };
    }
    
    // 함수 분할 전략 생성
    static generateSplitStrategy(functionCode, analysis) {
        const strategy = {
            originalFunction: this.extractFunctionName(functionCode),
            newFunctions: [],
            refactoringSteps: []
        };
        
        // 복잡도에 따른 분할 전략
        if (analysis.cyclomaticComplexity > 10) {
            strategy.newFunctions.push({
                name: `${strategy.originalFunction}_validator`,
                purpose: '입력 검증 로직',
                complexity: 'LOW'
            });
            
            strategy.newFunctions.push({
                name: `${strategy.originalFunction}_processor`,
                purpose: '핵심 처리 로직',
                complexity: 'MEDIUM'
            });
            
            strategy.newFunctions.push({
                name: `${strategy.originalFunction}_formatter`,
                purpose: '결과 포맷팅 로직',
                complexity: 'LOW'
            });
        }
        
        // 중첩 깊이에 따른 분할 전략
        if (analysis.nestingDepth > 4) {
            strategy.refactoringSteps.push({
                step: 1,
                action: 'early return 패턴 적용',
                description: '조건문을 early return으로 변경'
            });
            
            strategy.refactoringSteps.push({
                step: 2,
                action: '중첩된 조건문 분리',
                description: '복잡한 조건문을 별도 함수로 분리'
            });
        }
        
        return strategy;
    }
}
```

---

## 🔄 코드 중복 관리

### **1. 중복 코드 식별 및 제거**

#### **중복 코드 검출 시스템**
```javascript
class DuplicateCodeDetector {
    // 중복 코드 검출
    static detectDuplicates(projectPath) {
        const files = this.scanProjectFiles(projectPath);
        const duplicates = [];
        
        for (let i = 0; i < files.length; i++) {
            for (let j = i + 1; j < files.length; j++) {
                const similarity = this.calculateSimilarity(files[i], files[j]);
                
                if (similarity > 0.8) { // 80% 이상 유사
                    duplicates.push({
                        file1: files[i].path,
                        file2: files[j].path,
                        similarity: similarity,
                        duplicateBlocks: this.findDuplicateBlocks(files[i], files[j])
                    });
                }
            }
        }
        
        return {
            totalDuplicates: duplicates.length,
            duplicates: duplicates,
            recommendations: this.generateDuplicateRecommendations(duplicates)
        };
    }
    
    // 중복 코드 권장사항 생성
    static generateDuplicateRecommendations(duplicates) {
        const recommendations = [];
        
        for (const duplicate of duplicates) {
            if (duplicate.similarity > 0.9) {
                recommendations.push({
                    type: 'EXTRACT_COMMON_MODULE',
                    files: [duplicate.file1, duplicate.file2],
                    similarity: duplicate.similarity,
                    action: '공통 모듈로 추출',
                    estimatedSavings: '코드 중복 90% 감소'
                });
            } else if (duplicate.similarity > 0.8) {
                recommendations.push({
                    type: 'REFACTOR_SHARED_LOGIC',
                    files: [duplicate.file1, duplicate.file2],
                    similarity: duplicate.similarity,
                    action: '공통 로직 함수로 추출',
                    estimatedSavings: '코드 중복 80% 감소'
                });
            }
        }
        
        return recommendations;
    }
}
```

### **2. 공통 모듈 추출**

#### **공통 모듈 추출 전략**
```javascript
class CommonModuleExtractor {
    // 공통 모듈 추출
    static extractCommonModules(duplicates) {
        const commonModules = [];
        
        for (const duplicate of duplicates) {
            if (duplicate.similarity > 0.9) {
                const commonModule = this.createCommonModule(duplicate);
                commonModules.push(commonModule);
            }
        }
        
        return {
            modules: commonModules,
            refactoringPlan: this.generateRefactoringPlan(commonModules)
        };
    }
    
    // 공통 모듈 생성
    static createCommonModule(duplicate) {
        const commonCode = this.extractCommonCode(duplicate.file1, duplicate.file2);
        const moduleName = this.generateModuleName(duplicate);
        
        return {
            name: moduleName,
            path: `utils/${moduleName}.py`,
            code: commonCode,
            dependencies: this.analyzeDependencies(commonCode),
            usage: [duplicate.file1, duplicate.file2]
        };
    }
    
    // 리팩토링 계획 생성
    static generateRefactoringPlan(commonModules) {
        const plan = {
            steps: [],
            estimatedTime: 0,
            riskLevel: 'LOW'
        };
        
        for (const module of commonModules) {
            plan.steps.push({
                step: plan.steps.length + 1,
                action: `Create ${module.name}`,
                description: `${module.path} 파일 생성`,
                files: [module.path]
            });
            
            for (const usageFile of module.usage) {
                plan.steps.push({
                    step: plan.steps.length + 1,
                    action: `Refactor ${usageFile}`,
                    description: `${module.name} 모듈 사용하도록 변경`,
                    files: [usageFile]
                });
            }
        }
        
        plan.estimatedTime = plan.steps.length * 0.5; // 단계당 30분
        plan.riskLevel = plan.steps.length > 10 ? 'MEDIUM' : 'LOW';
        
        return plan;
    }
}
```

---

## 📊 코드 품질 모니터링

### **1. 자동화된 품질 검증**

#### **품질 검증 파이프라인**
```javascript
class QualityValidationPipeline {
    // 품질 검증 실행
    static runQualityValidation(projectPath) {
        const results = {
            fileSize: FileSizeValidator.validateAllFiles(projectPath),
            folderStructure: FolderStructureValidator.validateFolderStructure(projectPath),
            functionComplexity: this.validateFunctionComplexity(projectPath),
            codeDuplication: DuplicateCodeDetector.detectDuplicates(projectPath),
            namingConventions: this.validateNamingConventions(projectPath)
        };
        
        results.overallScore = this.calculateOverallScore(results);
        results.status = results.overallScore >= 80 ? 'PASS' : 'NEEDS_IMPROVEMENT';
        results.recommendations = this.generateOverallRecommendations(results);
        
        return results;
    }
    
    // 전체 점수 계산
    static calculateOverallScore(results) {
        const weights = {
            fileSize: 0.25,
            folderStructure: 0.20,
            functionComplexity: 0.25,
            codeDuplication: 0.20,
            namingConventions: 0.10
        };
        
        let totalScore = 0;
        for (const [metric, weight] of Object.entries(weights)) {
            totalScore += results[metric].score * weight;
        }
        
        return Math.round(totalScore);
    }
    
    // 전체 권장사항 생성
    static generateOverallRecommendations(results) {
        const recommendations = [];
        
        // 파일 크기 관련
        if (results.fileSize.exceededFiles.length > 0) {
            recommendations.push({
                priority: 'HIGH',
                category: 'FILE_SIZE',
                action: '대용량 파일 분할',
                files: results.fileSize.exceededFiles,
                impact: '유지보수성 향상'
            });
        }
        
        // 함수 복잡도 관련
        if (results.functionComplexity.complexFunctions.length > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'FUNCTION_COMPLEXITY',
                action: '복잡한 함수 리팩토링',
                functions: results.functionComplexity.complexFunctions,
                impact: '코드 가독성 향상'
            });
        }
        
        // 코드 중복 관련
        if (results.codeDuplication.totalDuplicates > 0) {
            recommendations.push({
                priority: 'MEDIUM',
                category: 'CODE_DUPLICATION',
                action: '중복 코드 제거',
                duplicates: results.codeDuplication.duplicates,
                impact: '코드 재사용성 향상'
            });
        }
        
        return recommendations.sort((a, b) => {
            const priorityOrder = { 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1 };
            return priorityOrder[b.priority] - priorityOrder[a.priority];
        });
    }
}
```

### **2. 지속적 모니터링**

#### **모니터링 대시보드**
```javascript
class CodeQualityDashboard {
    // 품질 지표 대시보드
    static generateDashboard(projectPath) {
        const qualityData = QualityValidationPipeline.runQualityValidation(projectPath);
        
        return {
            summary: {
                overallScore: qualityData.overallScore,
                status: qualityData.status,
                lastUpdated: new Date().toISOString(),
                trend: this.calculateTrend(projectPath)
            },
            
            metrics: {
                fileSize: {
                    totalFiles: qualityData.fileSize.totalFiles,
                    compliantFiles: qualityData.fileSize.compliantFiles,
                    complianceRate: Math.round((qualityData.fileSize.compliantFiles / qualityData.fileSize.totalFiles) * 100)
                },
                
                functionComplexity: {
                    totalFunctions: qualityData.functionComplexity.totalFunctions,
                    simpleFunctions: qualityData.functionComplexity.simpleFunctions,
                    complexFunctions: qualityData.functionComplexity.complexFunctions,
                    averageComplexity: qualityData.functionComplexity.averageComplexity
                },
                
                codeDuplication: {
                    totalDuplicates: qualityData.codeDuplication.totalDuplicates,
                    duplicateLines: qualityData.codeDuplication.duplicateLines,
                    duplicationRate: qualityData.codeDuplication.duplicationRate
                }
            },
            
            recommendations: qualityData.recommendations,
            
            history: this.getQualityHistory(projectPath)
        };
    }
    
    // 품질 트렌드 계산
    static calculateTrend(projectPath) {
        const history = this.getQualityHistory(projectPath);
        
        if (history.length < 2) {
            return 'INSUFFICIENT_DATA';
        }
        
        const recentScores = history.slice(-5).map(h => h.overallScore);
        const trend = this.calculateLinearTrend(recentScores);
        
        if (trend > 1) {
            return 'IMPROVING';
        } else if (trend < -1) {
            return 'DECLINING';
        } else {
            return 'STABLE';
        }
    }
}
```

---

## 🎯 구현 우선순위

### **Phase 1: 기본 구조 설정 (1주)**
1. **파일 크기 제한 시스템**: 자동화된 파일 크기 검증 도구 구현
2. **폴더 구조 표준화**: 표준 폴더 구조 적용 및 검증
3. **함수 크기 관리**: 함수 크기 및 복잡도 분석 도구 구현

### **Phase 2: 중복 제거 및 최적화 (1주)**
1. **중복 코드 검출**: 자동화된 중복 코드 검출 시스템
2. **공통 모듈 추출**: 중복 코드를 공통 모듈로 추출
3. **리팩토링 자동화**: 자동화된 리팩토링 도구 구현

### **Phase 3: 품질 모니터링 (1주)**
1. **품질 검증 파이프라인**: CI/CD에 통합된 품질 검증
2. **대시보드 구현**: 실시간 품질 지표 대시보드
3. **지속적 모니터링**: 자동화된 품질 모니터링 시스템

---

## 🧪 테스트 시나리오

### **1. 파일 크기 검증 테스트**
```javascript
describe('File Size Validation Tests', () => {
    test('모든 파일이 크기 제한을 준수', () => {
        const validationResults = FileSizeValidator.validateAllFiles('./src');
        
        expect(validationResults.exceededFiles.length).toBe(0);
        expect(validationResults.complianceRate).toBe(100);
    });
    
    test('대용량 파일 자동 분할 제안', () => {
        const largeFile = './src/services/large_service.py';
        const result = FileSizeValidator.validateFileSize(largeFile);
        
        if (!result.isWithinLimit) {
            expect(result.recommendation.action).toBe('FILE_SPLIT');
            expect(result.recommendation.splitStrategy).toBeDefined();
        }
    });
});
```

### **2. 함수 복잡도 검증 테스트**
```javascript
describe('Function Complexity Tests', () => {
    test('함수 복잡도 목표 달성', () => {
        const complexityResults = FunctionComplexityManager.analyzeAllFunctions('./src');
        
        expect(complexityResults.averageComplexity).toBeLessThan(10);
        expect(complexityResults.complexFunctions.length).toBeLessThan(5);
    });
    
    test('복잡한 함수 자동 분할 제안', () => {
        const complexFunction = 'function processUserData(userId) { /* 복잡한 로직 */ }';
        const analysis = FunctionComplexityManager.analyzeFunctionComplexity(complexFunction);
        
        if (analysis.overallScore < 70) {
            expect(analysis.recommendations.length).toBeGreaterThan(0);
        }
    });
});
```

---

**작성자**: AI Assistant (Seo Daeri)  
**작성일**: 2024-12-19  
**기준**: ACIU S4 검증된 코드 관리 경험 + 간결성 원칙
