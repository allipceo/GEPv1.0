# QManager 개발 실패 교훈서 v1.0

## 📋 **문서 개요**
- **작성일**: 2025년 8월 28일
- **프로젝트**: QManager (진위형 문제 관리 시스템)
- **상태**: 개발 실패 → 롤백 결정
- **개발 기간**: 3일 (2025.08.26 ~ 2025.08.28)

---

## 🚨 **실패 요약**

### **첫 번째 실패 (2025.08.26)**
- **실패 원인**: 완전 새로 개발하여 기존 QGENERATOR 코드 무시
- **결과**: 10시간 개발 후 롤백

### **두 번째 실패 (2025.08.28)**
- **실패 원인**: 복잡한 무한 재귀 오류와 데이터 처리 문제
- **결과**: 3일간 고전 후 롤백 결정

---

## 🔍 **두 번째 실패 상세 분석**

### **1. 초기 성공 요인**
✅ **QGENERATOR 코드 재사용 전략 성공**
- `qgenerator/js/qgenerator.js` → `qmanager/js/qmanager.js` 복사
- 기존 검증된 로직 활용
- QCODE 생성 규칙 정확히 준수

✅ **조건부 UI 구현 성공**
- 관리 모드 vs 생성 모드 전환
- 체크박스 기반 문제 선택 로직
- `selectedOriginal` 설정 로직

### **2. 시행착오 과정 상세 기록**

#### **Phase 1: 기본 구조 복사 및 수정 (2025.08.26)**
```
✅ 성공: QGENERATOR 코드 기반 QManager 구조 생성
- qmanager/index.html: QGENERATOR HTML 복사 후 제목/경로 수정
- qmanager/styles.css: QGENERATOR CSS 복사 후 QManager 스타일 추가
- qmanager/js/qmanager.js: QGENERATOR JS 복사 후 클래스명 변경
```

#### **Phase 2: 조건부 UI 로직 구현 (2025.08.27)**
```
✅ 성공: 기출문제 선택 시 관리/생성 모드 전환
- selectOriginalQuestion() 함수 수정
- showManagementMode() 함수 구현
- showGenerationMode() 함수 구현
- backToManagementMode() 함수 구현
```

#### **Phase 3: 데이터 수집 로직 수정 (2025.08.27)**
```
❌ 실패: collectGeneratedQuestions() 함수 DOM 셀렉터 문제
- 문제: document.querySelectorAll('.question-input')[i]가 예상과 다른 요소 선택
- 결과: 원본 문제 텍스트를 파생 문제로 잘못 인식
- 해결 시도: data-index 속성 확인, 셀렉터 수정
```

#### **Phase 4: QCODE 생성 로직 수정 (2025.08.27)**
```
❌ 실패: generateQCode() 함수의 순차 인덱스 문제
- 문제: 기존 데이터와 새 데이터 간의 인덱스 충돌
- 결과: ABBA-37-B1, B2가 이미 존재하는데 B1, B2로 재할당 시도
- 해결 시도: assignUniqueQCodes() 함수 구현
```

#### **Phase 5: 중복 문제 해결 시도 (2025.08.27)**
```
❌ 실패: assignUniqueQCodes() 함수의 무한 루프
- 문제: while (usedIndices.has(i)) i += 1; 무한 루프 발생
- 결과: RangeError: Maximum call stack size exceeded
- 해결 시도: maxAttempts 카운터 추가
```

#### **Phase 6: 데이터 저장/업로드 로직 수정 (2025.08.27)**
```
❌ 실패: saveGeneratedQuestions() 함수의 null 참조 오류
- 문제: this.selectedOriginal이 null인 상태에서 QNUM 접근
- 결과: TypeError: Cannot read properties of null (reading 'QNUM')
- 해결 시도: null 체크 로직 추가
```

#### **Phase 7: 브라우저 캐싱 문제 대응 (2025.08.27-28)**
```
❌ 실패: 수정된 JavaScript가 즉시 반영되지 않음
- 문제: 브라우저 캐시로 인한 구버전 코드 실행
- 결과: 수정사항이 반영되지 않아 디버깅 어려움
- 해결 시도: 강제 새로고침, 개발자 도구 캐시 비우기
```

#### **Phase 8: 체크박스 로직 개선 (2025.08.28)**
```
✅ 부분 성공: 체크된 문제만 처리하는 로직 구현
- 문제: 체크되지 않은 빈 문제도 생성되는 현상
- 해결: 체크박스 상태 확인 로직 강화
- 결과: "문제 1, 2개만 생성했는데 4개가 생성됨" 문제 해결
```

#### **Phase 9: 무한 재귀 오류 최종 대응 (2025.08.28)**
```
❌ 실패: 무한 재귀 오류 지속 발생
- 문제: KOFA2RMA.js에서 String.replace 무한 호출
- 결과: Maximum call stack size exceeded
- 해결 시도: 안전장치 추가했으나 근본 원인 해결 실패
```

### **3. 구체적 실패 원인 분석**

#### **A. 무한 재귀 오류 (RangeError: Maximum call stack size exceeded)**
```
오류 위치: KOFA2RMA.js:39, KOFA2RMA.js:42
원인: assignUniqueQCodes() 함수의 무한 루프 + String.replace 무한 호출
```

**구체적 원인:**
1. **QCODE 중복 방지 로직의 무한 루프**
   ```javascript
   while (usedIndices.has(i)) i += 1; // 무한 루프 가능성
   ```

2. **기존 데이터와 새 데이터 간의 인덱스 충돌**
   - ABBA-37-B1, B2가 이미 존재
   - 새로 생성된 문제가 B3, B4로 할당되면서 중복 발생

3. **String.replace 무한 호출**
   - KOFA2RMA.js에서 문자열 치환 과정에서 무한 재귀 발생
   - 정확한 원인 파악 실패

#### **B. 데이터 처리 문제**
```
문제: "문제 1, 2개만 생성했는데 4개가 생성됨"
원인: collectGeneratedQuestions() 함수의 DOM 셀렉터 문제
```

**구체적 원인:**
1. **DOM 셀렉터 불일치**
   - `document.querySelectorAll('.question-input')[i]`가 예상과 다른 요소 선택
   - 원본 문제 텍스트를 파생 문제로 잘못 인식

2. **체크박스 상태 추적 문제**
   - 체크되지 않은 문제도 처리되는 경우 발생

3. **HTML 구조 변경으로 인한 셀렉터 불일치**
   - QGENERATOR에서 복사한 HTML 구조가 QManager에서 변경됨
   - data-index 속성과 실제 DOM 구조 불일치

#### **C. 브라우저 캐싱 문제**
```
문제: 수정된 JavaScript가 즉시 반영되지 않음
원인: 브라우저 캐시로 인한 구버전 코드 실행
```

**구체적 원인:**
1. **브라우저 캐시로 인한 구버전 코드 실행**
2. **개발자 도구 캐시 설정 문제**
3. **강제 새로고침 필요성 무시**

#### **D. 데이터베이스 동기화 문제**
```
문제: gep_generated_questions.json 파일 업데이트 실패
원인: handleUpload() 함수의 파일 다운로드 방식
```

**구체적 원인:**
1. **handleUpload() 함수가 파일 다운로드만 수행**
2. **서버 측 파일 업데이트 로직 부재**
3. **수동으로 JSON 파일 수정 필요**

---

## 📚 **핵심 교훈 (Lessons Learned)**

### **1. 코드 재사용 전략의 한계**
```
✅ 성공: 기존 검증된 코드 복사
❌ 실패: 복잡한 조건부 로직 추가 시 예상치 못한 부작용
```

**교훈**: 
- 단순 복사가 아닌 **모듈화된 재사용** 필요
- **점진적 기능 추가** 방식 채택
- **각 단계별 철저한 테스트** 필수
- **기존 코드 구조 변경 시 영향도 분석** 필수

### **2. 무한 재귀 방지의 중요성**
```
❌ 실패: while 루프에 안전장치 없음
✅ 해결: maxAttempts 카운터 추가
```

**교훈**:
- **모든 반복문에 안전장치** 필수
- **최대 시도 횟수 제한** 설정
- **무한 루프 가능성 사전 검토**
- **재귀 함수 호출 깊이 제한** 설정

### **3. DOM 조작의 복잡성**
```
❌ 실패: 복잡한 DOM 셀렉터로 인한 예상치 못한 동작
✅ 해결: 명확한 data-attribute 사용
```

**교훈**:
- **명확한 data-attribute** 사용
- **DOM 구조 단순화** 필요
- **셀렉터 테스트** 철저히 수행
- **HTML 구조 변경 시 셀렉터 재검토** 필수

### **4. 브라우저 캐싱 관리**
```
❌ 실패: 수정사항이 즉시 반영되지 않음
✅ 해결: 강제 새로고침 및 캐시 비우기
```

**교훈**:
- **개발 중 캐시 비활성화** 설정
- **강제 새로고침** 습관화
- **개발자 도구 활용** 필수
- **버전 관리 및 캐시 무효화** 전략 수립

### **5. 데이터베이스 동기화 전략**
```
❌ 실패: 파일 다운로드 방식으로 인한 동기화 문제
✅ 해결: API 기반 서버 측 업데이트
```

**교훈**:
- **서버 측 파일 업데이트** 로직 구현
- **API 기반 데이터 동기화** 사용
- **파일 다운로드 vs 서버 업데이트** 구분 명확화
- **데이터 무결성 검증** 로직 추가

### **6. 에러 핸들링의 중요성**
```
❌ 실패: null 참조 오류로 인한 시스템 중단
✅ 해결: null 체크 및 예외 처리 로직 추가
```

**교훈**:
- **모든 객체 접근 전 null 체크** 필수
- **예외 처리 로직** 철저히 구현
- **사용자 친화적 에러 메시지** 제공
- **에러 로깅 및 모니터링** 시스템 구축

### **7. 개발 프로세스 개선**
```
❌ 실패: 한번에 모든 기능 구현 시도
✅ 해결: 단계별 점진적 개발
```

**교훈**:
- **MVP (Minimum Viable Product)** 우선 개발
- **기능별 단위 테스트** 작성
- **사용자 피드백** 조기 수집
- **반복적 개선** 프로세스 적용

---

## 🎯 **롤백 후 재개발 시 주의사항**

### **1. 아키텍처 설계**
```
✅ 권장: 모듈화된 컴포넌트 설계
❌ 금지: 단일 파일에 모든 로직 집중
```

**구체적 방안**:
- `qmanager-core.js`: 핵심 로직
- `qmanager-ui.js`: UI 조작
- `qmanager-data.js`: 데이터 처리

### **2. 개발 방법론**
```
✅ 권장: TDD (Test-Driven Development)
❌ 금지: 한번에 모든 기능 구현
```

**구체적 방안**:
1. **단위 테스트** 먼저 작성
2. **기능별 점진적 개발**
3. **각 단계별 검증**

### **3. 데이터 처리 전략**
```
✅ 권장: 불변성(Immutability) 원칙
❌ 금지: 직접 객체 수정
```

**구체적 방안**:
- **새 객체 생성** 방식 사용
- **데이터 검증** 강화
- **에러 핸들링** 철저히

### **4. UI/UX 설계**
```
✅ 권장: 단순하고 직관적인 인터페이스
❌ 금지: 복잡한 조건부 UI
```

**구체적 방안**:
- **명확한 상태 관리**
- **사용자 피드백** 강화
- **로딩 상태** 표시

---

## 🔄 **롤백 후 대안 전략**

### **옵션 1: QGENERATOR만 사용**
```
장점: 안정적, 검증됨
단점: 기능 제한적
```

### **옵션 2: 완전 새로 개발**
```
장점: 깔끔한 설계 가능
단점: 개발 시간 소요
```

### **옵션 3: 점진적 기능 추가**
```
장점: 안정성 확보
단점: 복잡성 증가
```

---

## 📝 **결론**

### **실패의 핵심 원인**
1. **복잡한 조건부 로직**의 예상치 못한 부작용
   - QGENERATOR 코드 복사 후 조건부 UI 추가 시 예상치 못한 상호작용
   - DOM 셀렉터와 HTML 구조 변경으로 인한 불일치

2. **무한 재귀** 방지 로직 부재
   - assignUniqueQCodes() 함수의 while 루프 무한 반복
   - String.replace 무한 호출로 인한 스택 오버플로우

3. **DOM 조작**의 복잡성 과소평가
   - 복사된 HTML 구조 변경 시 셀렉터 불일치
   - data-index 속성과 실제 DOM 구조 동기화 실패

4. **브라우저 캐싱** 문제 무시
   - 수정된 JavaScript 즉시 반영 안됨
   - 디버깅 어려움으로 인한 문제 해결 지연

5. **데이터베이스 동기화** 전략 부재
   - 파일 다운로드 방식으로 인한 서버 측 업데이트 실패
   - 수동 JSON 파일 수정 필요

### **성공을 위한 필수 요소**
1. **단순한 아키텍처** 설계
   - 모듈화된 컴포넌트 분리
   - 명확한 책임 분리

2. **철저한 테스트** 기반 개발
   - 단위 테스트 우선 작성
   - 각 기능별 검증

3. **점진적 기능** 추가
   - MVP 우선 개발
   - 반복적 개선

4. **안전장치** 포함한 모든 로직
   - 무한 루프 방지
   - null 체크 및 예외 처리

5. **사용자 중심** 설계
   - 직관적인 인터페이스
   - 명확한 피드백

### **다음 개발 시 핵심 원칙**
> **"단순함이 최고의 복잡함이다"**
> - 복잡한 기능보다 **안정적인 기본 기능** 우선
> - **검증된 패턴** 사용
> - **사용자 중심** 설계
> - **점진적 개선** 방식 채택

### **롤백 후 재개발 전략**
1. **QGENERATOR 완전 검증 상태로 복원**
2. **이 교훈서를 바탕으로 완전 새로 개발**
3. **모듈화된 아키텍처로 설계**
4. **단계별 점진적 개발 방식 적용**

### **최종 교훈**
> **"실패는 성공의 어머니"**
> - 이번 실패 경험이 다음 성공의 기반이 될 것
> - 교훈을 바탕으로 더 나은 시스템 구축 가능
> - 조대표님의 인내와 지도력이 프로젝트 성공의 핵심

---

**작성자**: 서대리 (AI Assistant)  
**검토자**: 조대표님  
**다음 검토일**: 재개발 시작 시
