# GEP V1.0 핵심 함수 설계 (레고블록 방법론)

## 📋 개요
**General Exam Platform (GEP) V1.0** - 핵심 함수 설계 및 아키텍처 가이드
**기준**: ACIU S4 검증된 아키텍처 + 레고블록 방법론
**목표**: 실용적이고 확장 가능한 핵심 함수 설계

---

## 🎯 핵심 설계 원칙

### **ACIU S4 검증된 패턴 적용**
- **중앙집중식 데이터 관리**: 모든 데이터 변경은 중앙 아키텍처를 통해서만
- **이벤트 기반 시스템**: 데이터 변경 시 자동 UI 업데이트
- **모듈화 전략**: 200줄 이하 파일, 70% 이상 재사용률
- **실용적 최적화**: 복잡한 추상화보다 직관적 해결책

### **레고블록 방법론**
- **작은 모듈**: 각 함수는 단일 책임 원칙
- **재사용성**: 여러 서비스 레벨에서 공통 사용
- **확장성**: 새로운 기능 추가 시 기존 함수 활용

---

## 🔧 핵심 함수 설계

### **1. 문제 제공 함수 (레벨별 필터링)**

#### **QuestionService 클래스**
```javascript
class QuestionService {
    // 1. 회차별 문제 제공 (무료 서비스)
    getQuestionsByRound(roundNumber, limit = 40) {
        // 기존 GEP_MASTER 데이터 활용
        // 회차별 필터링
        // 기본 40문제 제한
    }
    
    // 2. 과목별 문제 제공 (중급 서비스)
    getQuestionsBySubject(subject, limit = 100) {
        // 과목별 필터링
        // 서비스 레벨 확인
        // 진도 기반 추천
    }
    
    // 3. 맞춤형 문제 제공 (고급 서비스)
    getPersonalizedQuestions(userId, limit = 20) {
        // 오답 분석 기반
        // 난이도 조정
        // 학습 패턴 분석
    }
    
    // 4. 진위형 문제 생성 (고급 서비스)
    generateTrueFalseQuestions(mcqQuestion) {
        // 기존 객관식 문제 기반
        // 8개 진위형 문제 생성
        // 난이도 조정
    }
}
```

#### **실용적 구현 예시**
```javascript
// 간단한 회차별 문제 제공
function getQuestionsByRound(roundNumber) {
    const questions = gepMasterData.filter(q => 
        q.EROUND === roundNumber && 
        q.STATUS === 'active'
    );
    
    return questions.slice(0, 40); // 기본 40문제
}

// 서비스 레벨별 접근 제어
function checkServiceLevel(userId, requiredLevel) {
    const user = getUserById(userId);
    return user.serviceLevel >= requiredLevel;
}
```

### **2. 정답 체크 함수 (통계 자동 업데이트)**

#### **AnswerService 클래스**
```javascript
class AnswerService {
    // 1. 정답 확인 및 통계 업데이트
    checkAnswer(questionId, userAnswer, userId) {
        const question = getQuestionById(questionId);
        const isCorrect = question.ANSWER === userAnswer;
        
        // 중앙 아키텍처에 결과 전송
        CentralDataManager.recordAnswer({
            questionId,
            userId,
            userAnswer,
            correctAnswer: question.ANSWER,
            isCorrect,
            timestamp: new Date().toISOString()
        });
        
        return {
            isCorrect,
            correctAnswer: question.ANSWER,
            explanation: question.EXPLANATION || null
        };
    }
    
    // 2. 진도 업데이트
    updateProgress(userId, questionId, isCorrect) {
        // 이어풀기 정보 업데이트
        ProgressManager.updateProgress(userId, questionId);
        
        // 통계 업데이트
        StatisticsManager.updateStatistics(userId, isCorrect);
        
        // 실시간 UI 업데이트
        RealtimeSyncManager.broadcastUpdate();
    }
}
```

#### **중앙 아키텍처 연동**
```javascript
// ACIU S4 검증된 패턴 적용
class CentralDataManager {
    static recordAnswer(answerData) {
        // 1. 문제 풀이 결과 저장
        this.saveQuizResult(answerData);
        
        // 2. 카테고리별 통계 업데이트
        this.updateCategoryStatistics(answerData);
        
        // 3. 실시간 데이터 업데이트
        this.updateRealTimeData(answerData);
        
        // 4. 예상 점수 재계산
        this.recalculatePredictedScores();
        
        // 5. 이벤트 브로드캐스트
        this.broadcastDataUpdate();
    }
}
```

### **3. 사용자 관리 함수 (간단한 인증)**

#### **UserService 클래스**
```javascript
class UserService {
    // 1. 사용자 등록 (게스트/실제 사용자)
    registerUser(userData) {
        const user = {
            id: generateUserId(),
            name: userData.name || '게스트',
            email: userData.email || null,
            serviceLevel: 'FREE', // 기본값
            registrationDate: new Date().toISOString(),
            examDate: userData.examDate || null,
            preferences: {}
        };
        
        // LocalStorage 저장
        this.saveUser(user);
        
        // 통계 데이터 초기화
        this.initializeUserStatistics(user.id);
        
        return user;
    }
    
    // 2. 서비스 레벨 업그레이드
    upgradeServiceLevel(userId, newLevel) {
        const user = this.getUserById(userId);
        user.serviceLevel = newLevel;
        user.upgradeDate = new Date().toISOString();
        
        this.saveUser(user);
        
        // 새로운 기능 활성화
        this.activateNewFeatures(userId, newLevel);
    }
    
    // 3. 사용자 데이터 관리
    getUserStatistics(userId) {
        return {
            basic: this.getBasicStatistics(userId),
            detailed: this.getDetailedStatistics(userId),
            progress: this.getProgressData(userId)
        };
    }
}
```

#### **실용적 인증 시스템**
```javascript
// 간단한 세션 관리
class SessionManager {
    static createSession(userId) {
        const session = {
            userId,
            startTime: new Date().toISOString(),
            lastActivity: new Date().toISOString()
        };
        
        localStorage.setItem('gep_session', JSON.stringify(session));
        return session;
    }
    
    static getCurrentUser() {
        const session = localStorage.getItem('gep_session');
        if (!session) return null;
        
        const sessionData = JSON.parse(session);
        return getUserById(sessionData.userId);
    }
}
```

---

## 📊 데이터 플로우 설계

### **1. 문제 풀이 플로우**
```
사용자 문제 선택 → QuestionService.getQuestions() → 
UI 표시 → 사용자 답안 제출 → 
AnswerService.checkAnswer() → CentralDataManager.recordAnswer() → 
실시간 통계 업데이트 → UI 자동 업데이트
```

### **2. 사용자 등록 플로우**
```
앱 시작 → SessionManager.getCurrentUser() → 
사용자 없음 → UserService.registerUser() → 
통계 초기화 → 홈페이지 이동
```

### **3. 서비스 레벨 업그레이드 플로우**
```
결제 완료 → UserService.upgradeServiceLevel() → 
새 기능 활성화 → UI 업데이트 → 
고급 기능 사용 가능
```

---

## 🔄 함수 간 의존성 관리

### **의존성 주입 패턴**
```javascript
// 서비스 간 의존성 관리
class ServiceContainer {
    constructor() {
        this.questionService = new QuestionService();
        this.answerService = new AnswerService();
        this.userService = new UserService();
        this.statisticsService = new StatisticsService();
    }
    
    // 중앙 아키텍처 초기화
    initializeCentralArchitecture() {
        CentralDataManager.initialize({
            questionService: this.questionService,
            userService: this.userService,
            statisticsService: this.statisticsService
        });
    }
}
```

### **모듈 간 통신**
```javascript
// 이벤트 기반 통신 (ACIU S4 패턴)
class EventBus {
    static emit(eventName, data) {
        window.dispatchEvent(new CustomEvent(eventName, { detail: data }));
    }
    
    static on(eventName, callback) {
        window.addEventListener(eventName, (e) => callback(e.detail));
    }
}

// 사용 예시
EventBus.emit('answerSubmitted', { questionId, isCorrect });
EventBus.on('statisticsUpdated', (data) => updateUI(data));
```

---

## 🎯 성능 최적화 전략

### **1. 캐싱 전략**
```javascript
// 문제 데이터 캐싱
class QuestionCache {
    constructor() {
        this.cache = new Map();
        this.maxSize = 1000;
    }
    
    get(roundNumber) {
        if (this.cache.has(roundNumber)) {
            return this.cache.get(roundNumber);
        }
        
        const questions = loadQuestionsFromDatabase(roundNumber);
        this.cache.set(roundNumber, questions);
        
        // 캐시 크기 관리
        if (this.cache.size > this.maxSize) {
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        
        return questions;
    }
}
```

### **2. 지연 로딩**
```javascript
// 필요할 때만 데이터 로드
class LazyLoader {
    static async loadUserStatistics(userId) {
        // 기본 통계만 먼저 로드
        const basicStats = await loadBasicStatistics(userId);
        
        // 상세 통계는 필요할 때 로드
        return {
            basic: basicStats,
            detailed: () => loadDetailedStatistics(userId)
        };
    }
}
```

---

## 🧪 테스트 전략

### **1. 단위 테스트**
```javascript
// 핵심 함수별 테스트
describe('QuestionService', () => {
    test('getQuestionsByRound returns correct number of questions', () => {
        const questions = QuestionService.getQuestionsByRound(28);
        expect(questions.length).toBeLessThanOrEqual(40);
    });
    
    test('checkServiceLevel correctly validates access', () => {
        const hasAccess = checkServiceLevel('user123', 'PREMIUM');
        expect(hasAccess).toBe(false); // FREE 사용자는 PREMIUM 접근 불가
    });
});
```

### **2. 통합 테스트**
```javascript
// 전체 플로우 테스트
describe('Complete Quiz Flow', () => {
    test('user can complete a quiz and see updated statistics', async () => {
        // 1. 사용자 등록
        const user = await UserService.registerUser({ name: 'Test User' });
        
        // 2. 문제 풀이
        const questions = QuestionService.getQuestionsByRound(28);
        const result = AnswerService.checkAnswer(questions[0].id, 'A', user.id);
        
        // 3. 통계 확인
        const stats = UserService.getUserStatistics(user.id);
        expect(stats.basic.totalQuestions).toBe(1);
    });
});
```

---

## 📈 확장성 고려사항

### **1. 새로운 시험 유형 추가**
```javascript
// 확장 가능한 시험 타입 시스템
class ExamTypeManager {
    static getExamTypes() {
        return {
            'INSURANCE_BROKER': {
                name: '보험중개사',
                subjects: ['관계법령', '손보1부', '손보2부'],
                questionCount: 40
            },
            'LOSS_ADJUSTER': {
                name: '보험심사역',
                subjects: ['재산보험', '특종보험', '배상책임보험', '해상보험'],
                questionCount: 40
            }
            // 새로운 시험 유형 쉽게 추가 가능
        };
    }
}
```

### **2. 새로운 통계 유형 추가**
```javascript
// 플러그인 방식 통계 시스템
class StatisticsPluginManager {
    static registerPlugin(pluginName, pluginFunction) {
        this.plugins[pluginName] = pluginFunction;
    }
    
    static calculateAllStatistics(userId) {
        const results = {};
        Object.keys(this.plugins).forEach(pluginName => {
            results[pluginName] = this.plugins[pluginName](userId);
        });
        return results;
    }
}
```

---

## 🎯 구현 우선순위

### **Phase 1: 핵심 함수 (1-2개월)**
1. **QuestionService**: 회차별 문제 제공
2. **AnswerService**: 정답 체크 및 기본 통계
3. **UserService**: 간단한 사용자 관리

### **Phase 2: 고급 함수 (1개월)**
1. **과목별 필터링**: 중급 서비스용
2. **상세 통계**: 고급 분석 기능
3. **진위형 문제**: 고급 서비스용

### **Phase 3: 최적화 (1개월)**
1. **캐싱 시스템**: 성능 최적화
2. **확장성 개선**: 새로운 시험 유형 지원
3. **테스트 완성**: 안정성 보장

---

**작성자**: AI Assistant (Seo Daeri)  
**작성일**: 2024-12-19  
**기준**: ACIU S4 검증된 아키텍처 + 레고블록 방법론
