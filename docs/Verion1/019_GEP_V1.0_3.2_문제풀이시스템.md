# GEP V1.0 문제 풀이 시스템 설계

## 📋 개요
**General Exam Platform (GEP) V1.0** - 문제 풀이 시스템 설계
**기준**: ACIU S4 검증된 아키텍처 + GEP 요구사항
**목표**: 일관된 인터페이스와 정확한 이어풀기 시스템

---

## 🎯 핵심 설계 원칙

### **ACIU S4 검증된 패턴 적용**
- **중앙집중식 데이터 관리**: 모든 문제 풀이 결과는 중앙 아키텍처를 통해서만
- **이벤트 기반 시스템**: 정답 확인 시 자동 통계 업데이트
- **이어풀기 시스템**: 정확한 진도 추적 및 복원
- **일관된 인터페이스**: 시험 종류나 과목에 관계없이 동일한 UI

### **GEP 특화 요구사항**
- **범용 플랫폼**: 보험중개사, 보험심사역 등 다양한 시험 지원
- **3단계 문제 유형**: 객관식, 진위형, 맞춤형 문제
- **실시간 통계**: 문제 풀이 즉시 모든 통계 반영
- **모바일 최적화**: 터치 친화적 인터페이스

---

## 🔄 문제 풀이 시스템 아키텍처

### **1. 핵심 데이터 플로우**

#### **문제 풀이 전체 플로우**
```
사용자 문제 선택 → 문제 로드 → UI 표시 → 
사용자 답안 선택 → 정답 확인 → 결과 처리 → 
중앙 데이터 업데이트 → 통계 반영 → UI 업데이트 → 
다음 문제 준비
```

#### **중앙 아키텍처 연동**
```javascript
// ACIU S4 검증된 패턴 적용
class CentralDataManager {
    static handleQuestionCompleted(questionData) {
        // 1. 문제 풀이 결과 저장
        this.saveQuizResult(questionData);
        
        // 2. 진도 업데이트
        this.updateProgress(questionData);
        
        // 3. 통계 업데이트
        this.updateStatistics(questionData);
        
        // 4. 이어풀기 정보 업데이트
        this.updateContinueLearning(questionData);
        
        // 5. 실시간 UI 업데이트
        this.broadcastDataUpdate();
    }
}
```

### **2. 문제 제공 시스템**

#### **QuestionProvider 클래스**
```javascript
class QuestionProvider {
    // 1. 회차별 문제 제공 (무료 서비스)
    static getQuestionsByRound(roundNumber, limit = 40) {
        const questions = gepMasterData.filter(q => 
            q.EROUND === roundNumber && 
            q.STATUS === 'active'
        );
        
        return questions.slice(0, limit);
    }
    
    // 2. 과목별 문제 제공 (중급 서비스)
    static getQuestionsBySubject(subject, userId, limit = 100) {
        // 서비스 레벨 확인
        if (!AccessControl.checkFeatureAccess('subjectFiltering')) {
            throw new Error('과목별 필터링은 중급 서비스 이상에서 이용 가능합니다.');
        }
        
        const questions = gepMasterData.filter(q => 
            q.LAYER1 === subject && 
            q.STATUS === 'active'
        );
        
        // 진도 기반 추천
        const userProgress = ProgressManager.getUserProgress(userId, subject);
        return this.recommendQuestions(questions, userProgress, limit);
    }
    
    // 3. 맞춤형 문제 제공 (고급 서비스)
    static getPersonalizedQuestions(userId, limit = 20) {
        if (!AccessControl.checkFeatureAccess('personalizedQuestions')) {
            throw new Error('맞춤형 문제는 고급 서비스에서 이용 가능합니다.');
        }
        
        const userStats = StatisticsManager.getUserStatistics(userId);
        const weakSubjects = this.analyzeWeakSubjects(userStats);
        
        return this.generatePersonalizedQuestions(weakSubjects, limit);
    }
    
    // 4. 진위형 문제 생성 (고급 서비스)
    static generateTrueFalseQuestions(mcqQuestion) {
        if (!AccessControl.checkFeatureAccess('trueFalseQuestions')) {
            throw new Error('진위형 문제는 고급 서비스에서 이용 가능합니다.');
        }
        
        // 기존 객관식 문제 기반으로 8개 진위형 문제 생성
        return this.createTrueFalseQuestions(mcqQuestion);
    }
}
```

### **3. 문제 풀이 인터페이스**

#### **일관된 UI 컴포넌트**
```html
<!-- 문제 풀이 페이지 HTML 구조 -->
<div id="question-solving-container" class="min-h-screen bg-gray-50">
    <!-- 상단 진행률 표시 -->
    <div class="bg-white shadow-sm border-b">
        <div class="max-w-4xl mx-auto px-4 py-3">
            <div class="flex justify-between items-center">
                <div class="text-sm text-gray-600">
                    <span id="current-question-number">1</span> / <span id="total-questions">40</span>
                </div>
                <div class="text-sm text-gray-600">
                    정답률: <span id="current-accuracy">0%</span>
                </div>
                <div class="text-sm text-gray-600">
                    남은 시간: <span id="remaining-time">--:--</span>
                </div>
            </div>
            <!-- 진행률 바 -->
            <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                <div id="progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
    </div>
    
    <!-- 문제 내용 -->
    <div class="max-w-4xl mx-auto px-4 py-6">
        <div class="bg-white rounded-lg shadow-sm border p-6 mb-6">
            <div class="text-lg font-medium text-gray-900 mb-4">
                <span id="question-number">1</span>번 문제
            </div>
            <div id="question-content" class="text-gray-700 leading-relaxed mb-6">
                <!-- 문제 내용이 여기에 표시됩니다 -->
            </div>
        </div>
        
        <!-- 선택지 -->
        <div id="answer-options" class="space-y-3">
            <!-- 선택지가 여기에 동적으로 생성됩니다 -->
        </div>
        
        <!-- 하단 버튼 -->
        <div class="flex justify-between items-center mt-8">
            <button id="prev-question" onclick="goToPreviousQuestion()" 
                    class="px-6 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                이전 문제
            </button>
            
            <button id="check-answer" onclick="checkAnswer()" 
                    class="px-8 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-medium">
                정답 확인
            </button>
            
            <button id="next-question" onclick="goToNextQuestion()" 
                    class="px-6 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                다음 문제
            </button>
        </div>
    </div>
</div>
```

#### **문제 풀이 JavaScript 로직**
```javascript
class QuestionSolvingManager {
    constructor() {
        this.currentQuestionIndex = 0;
        this.questions = [];
        this.userAnswers = {};
        this.isAnswerChecked = false;
        this.startTime = null;
    }
    
    // 문제 풀이 시작
    async startQuestionSolving(roundNumber, subject = null) {
        try {
            // 문제 로드
            if (subject) {
                this.questions = await QuestionProvider.getQuestionsBySubject(subject, getCurrentUserId());
            } else {
                this.questions = QuestionProvider.getQuestionsByRound(roundNumber);
            }
            
            // 이어풀기 정보 확인
            const continueInfo = this.getContinueLearningInfo(roundNumber, subject);
            this.currentQuestionIndex = continueInfo.nextQuestionIndex;
            
            // UI 초기화
            this.initializeUI();
            
            // 첫 문제 표시
            this.displayQuestion(this.currentQuestionIndex);
            
            // 타이머 시작
            this.startTimer();
            
        } catch (error) {
            console.error('문제 풀이 시작 실패:', error);
            this.showError('문제를 불러오는데 실패했습니다.');
        }
    }
    
    // 문제 표시
    displayQuestion(questionIndex) {
        if (questionIndex < 0 || questionIndex >= this.questions.length) {
            return;
        }
        
        const question = this.questions[questionIndex];
        
        // 문제 번호 업데이트
        document.getElementById('question-number').textContent = questionIndex + 1;
        document.getElementById('current-question-number').textContent = questionIndex + 1;
        
        // 문제 내용 표시
        document.getElementById('question-content').innerHTML = this.formatQuestionContent(question.QUESTION);
        
        // 선택지 생성
        this.generateAnswerOptions(question);
        
        // 이전 답안 복원
        this.restoreUserAnswer(questionIndex);
        
        // 진행률 업데이트
        this.updateProgress();
        
        // 버튼 상태 업데이트
        this.updateButtonStates();
    }
    
    // 선택지 생성
    generateAnswerOptions(question) {
        const optionsContainer = document.getElementById('answer-options');
        optionsContainer.innerHTML = '';
        
        const options = ['A', 'B', 'C', 'D'];
        
        options.forEach(option => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'border border-gray-300 rounded-lg p-4 cursor-pointer hover:bg-gray-50 transition-colors';
            optionDiv.onclick = () => this.selectAnswer(option);
            optionDiv.id = `option-${option}`;
            
            optionDiv.innerHTML = `
                <div class="flex items-center">
                    <div class="w-8 h-8 bg-gray-200 rounded-full flex items-center justify-center mr-3 font-medium">
                        ${option}
                    </div>
                    <div class="flex-1">
                        ${this.extractOptionContent(question.QUESTION, option)}
                    </div>
                </div>
            `;
            
            optionsContainer.appendChild(optionDiv);
        });
    }
    
    // 답안 선택
    selectAnswer(selectedOption) {
        // 이전 선택 해제
        document.querySelectorAll('#answer-options > div').forEach(div => {
            div.classList.remove('bg-blue-100', 'border-blue-500');
            div.classList.add('border-gray-300');
        });
        
        // 새 선택 표시
        const selectedDiv = document.getElementById(`option-${selectedOption}`);
        selectedDiv.classList.remove('border-gray-300');
        selectedDiv.classList.add('bg-blue-100', 'border-blue-500');
        
        // 답안 저장
        this.userAnswers[this.currentQuestionIndex] = selectedOption;
        
        // 정답 확인 버튼 활성화
        document.getElementById('check-answer').disabled = false;
    }
    
    // 정답 확인
    async checkAnswer() {
        if (!this.userAnswers[this.currentQuestionIndex]) {
            this.showError('답안을 선택해주세요.');
            return;
        }
        
        const question = this.questions[this.currentQuestionIndex];
        const userAnswer = this.userAnswers[this.currentQuestionIndex];
        const isCorrect = question.ANSWER === userAnswer;
        
        // 결과 표시
        this.showAnswerResult(isCorrect, question.ANSWER, userAnswer);
        
        // 중앙 아키텍처에 결과 전송
        await CentralDataManager.handleQuestionCompleted({
            questionId: question.QCODE,
            userId: getCurrentUserId(),
            userAnswer: userAnswer,
            correctAnswer: question.ANSWER,
            isCorrect: isCorrect,
            questionType: question.QTYPE,
            subject: question.LAYER1,
            roundNumber: question.EROUND,
            timestamp: new Date().toISOString()
        });
        
        // 이어풀기 정보 업데이트
        this.updateContinueLearningInfo();
        
        // 다음 문제 버튼 활성화
        document.getElementById('next-question').disabled = false;
        document.getElementById('check-answer').disabled = true;
        
        this.isAnswerChecked = true;
    }
    
    // 정답 결과 표시
    showAnswerResult(isCorrect, correctAnswer, userAnswer) {
        // 모든 선택지 스타일 초기화
        document.querySelectorAll('#answer-options > div').forEach(div => {
            div.classList.remove('bg-blue-100', 'bg-green-100', 'bg-red-100', 'border-blue-500', 'border-green-500', 'border-red-500');
            div.classList.add('border-gray-300');
        });
        
        // 정답 표시
        const correctDiv = document.getElementById(`option-${correctAnswer}`);
        correctDiv.classList.remove('border-gray-300');
        correctDiv.classList.add('bg-green-100', 'border-green-500');
        
        // 오답 표시 (사용자가 틀렸을 경우)
        if (!isCorrect) {
            const userDiv = document.getElementById(`option-${userAnswer}`);
            userDiv.classList.remove('border-gray-300');
            userDiv.classList.add('bg-red-100', 'border-red-500');
        }
        
        // 결과 메시지 표시
        const message = isCorrect ? '정답입니다! 🎉' : `틀렸습니다. 정답은 ${correctAnswer}입니다.`;
        this.showMessage(message, isCorrect ? 'success' : 'error');
    }
    
    // 다음 문제로 이동
    goToNextQuestion() {
        if (this.currentQuestionIndex < this.questions.length - 1) {
            this.currentQuestionIndex++;
            this.displayQuestion(this.currentQuestionIndex);
            this.isAnswerChecked = false;
        } else {
            this.completeQuestionSolving();
        }
    }
    
    // 이전 문제로 이동
    goToPreviousQuestion() {
        if (this.currentQuestionIndex > 0) {
            this.currentQuestionIndex--;
            this.displayQuestion(this.currentQuestionIndex);
            this.isAnswerChecked = false;
        }
    }
    
    // 문제 풀이 완료
    completeQuestionSolving() {
        const totalQuestions = this.questions.length;
        const answeredQuestions = Object.keys(this.userAnswers).length;
        const correctAnswers = this.calculateCorrectAnswers();
        
        const result = {
            totalQuestions,
            answeredQuestions,
            correctAnswers,
            accuracy: Math.round((correctAnswers / answeredQuestions) * 100)
        };
        
        // 결과 페이지로 이동
        this.showCompletionResult(result);
    }
}
```

---

## 🔄 이어풀기 시스템

### **1. 진도 추적 시스템**

#### **ProgressManager 클래스**
```javascript
class ProgressManager {
    // 사용자별 진도 정보 조회
    static getUserProgress(userId, subject = null) {
        const progressData = localStorage.getItem(`gep_user_${userId}_progress`);
        if (!progressData) return this.initializeProgress(userId);
        
        const progress = JSON.parse(progressData);
        
        if (subject) {
            return progress[subject] || { currentQuestion: 1, completedQuestions: [] };
        }
        
        return progress;
    }
    
    // 진도 업데이트
    static updateProgress(userId, questionData) {
        const progress = this.getUserProgress(userId);
        const subject = questionData.subject;
        
        if (!progress[subject]) {
            progress[subject] = { currentQuestion: 1, completedQuestions: [] };
        }
        
        // 현재 문제 번호 업데이트
        progress[subject].currentQuestion = questionData.questionNumber + 1;
        
        // 완료된 문제 목록에 추가
        if (!progress[subject].completedQuestions.includes(questionData.questionNumber)) {
            progress[subject].completedQuestions.push(questionData.questionNumber);
        }
        
        // LocalStorage에 저장
        localStorage.setItem(`gep_user_${userId}_progress`, JSON.stringify(progress));
        
        // 중앙 아키텍처에 전송
        CentralDataManager.updateProgress(userId, progress);
    }
    
    // 이어풀기 정보 조회
    static getContinueLearningInfo(userId, subject) {
        const progress = this.getUserProgress(userId, subject);
        
        return {
            nextQuestionIndex: progress.currentQuestion - 1, // 0-based index
            completedCount: progress.completedQuestions.length,
            totalQuestions: this.getTotalQuestions(subject),
            progressPercentage: Math.round((progress.completedQuestions.length / this.getTotalQuestions(subject)) * 100)
        };
    }
    
    // 진도 초기화
    static initializeProgress(userId) {
        const initialProgress = {
            '관계법령': { currentQuestion: 1, completedQuestions: [] },
            '손보1부': { currentQuestion: 1, completedQuestions: [] },
            '손보2부': { currentQuestion: 1, completedQuestions: [] }
        };
        
        localStorage.setItem(`gep_user_${userId}_progress`, JSON.stringify(initialProgress));
        return initialProgress;
    }
}
```

### **2. 이어풀기 UI 표시**

#### **이어풀기 안내 컴포넌트**
```html
<!-- 이어풀기 안내 UI -->
<div id="continue-learning-banner" class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
    <div class="flex items-center justify-between">
        <div class="flex items-center">
            <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center mr-3">
                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                </svg>
            </div>
            <div>
                <h3 class="text-sm font-medium text-blue-900">이어풀기</h3>
                <p class="text-sm text-blue-700">
                    <span id="continue-question-number">21</span>번부터 계속하기
                </p>
            </div>
        </div>
        <button onclick="startContinueLearning()" 
                class="px-4 py-2 bg-blue-500 text-white text-sm rounded-lg hover:bg-blue-600 transition-colors">
            계속하기
        </button>
    </div>
</div>
```

#### **이어풀기 시작 함수**
```javascript
// 이어풀기 시작
function startContinueLearning() {
    const userId = getCurrentUserId();
    const continueInfo = ProgressManager.getContinueLearningInfo(userId, currentSubject);
    
    // 이어풀기 시작
    questionSolvingManager.startQuestionSolving(currentRound, currentSubject);
    
    // 첫 문제를 이어풀기 위치로 설정
    questionSolvingManager.currentQuestionIndex = continueInfo.nextQuestionIndex;
    questionSolvingManager.displayQuestion(continueInfo.nextQuestionIndex);
    
    // 배너 숨기기
    document.getElementById('continue-learning-banner').style.display = 'none';
}
```

---

## 📊 실시간 통계 업데이트

### **1. 통계 자동 업데이트**

#### **StatisticsManager 클래스**
```javascript
class StatisticsManager {
    // 문제 풀이 결과 통계 업데이트
    static updateStatistics(userId, questionData) {
        const stats = this.getUserStatistics(userId);
        
        // 기본 통계 업데이트
        stats.totalQuestionsAttempted++;
        if (questionData.isCorrect) {
            stats.totalCorrectAnswers++;
        }
        stats.accuracyRate = Math.round((stats.totalCorrectAnswers / stats.totalQuestionsAttempted) * 100);
        
        // 일별 통계 업데이트
        const today = new Date().toISOString().split('T')[0];
        if (!stats.dailyProgress[today]) {
            stats.dailyProgress[today] = {
                questionsAttempted: 0,
                correctAnswers: 0,
                accuracy: 0
            };
        }
        
        stats.dailyProgress[today].questionsAttempted++;
        if (questionData.isCorrect) {
            stats.dailyProgress[today].correctAnswers++;
        }
        stats.dailyProgress[today].accuracy = Math.round(
            (stats.dailyProgress[today].correctAnswers / stats.dailyProgress[today].questionsAttempted) * 100
        );
        
        // 과목별 통계 업데이트
        if (!stats.categoryStatistics[questionData.subject]) {
            stats.categoryStatistics[questionData.subject] = {
                questionsAttempted: 0,
                correctAnswers: 0,
                accuracy: 0
            };
        }
        
        stats.categoryStatistics[questionData.subject].questionsAttempted++;
        if (questionData.isCorrect) {
            stats.categoryStatistics[questionData.subject].correctAnswers++;
        }
        stats.categoryStatistics[questionData.subject].accuracy = Math.round(
            (stats.categoryStatistics[questionData.subject].correctAnswers / 
             stats.categoryStatistics[questionData.subject].questionsAttempted) * 100
        );
        
        // LocalStorage에 저장
        this.saveUserStatistics(userId, stats);
        
        // UI 업데이트
        this.updateStatisticsUI(stats);
    }
    
    // 실시간 UI 업데이트
    static updateStatisticsUI(stats) {
        // 정답률 업데이트
        document.getElementById('current-accuracy').textContent = `${stats.accuracyRate}%`;
        
        // 진행률 업데이트
        const progressPercentage = Math.round((stats.totalQuestionsAttempted / 789) * 100);
        document.getElementById('progress-bar').style.width = `${progressPercentage}%`;
        
        // 이벤트 발생
        EventBus.emit('statisticsUpdated', stats);
    }
}
```

### **2. 실시간 동기화**

#### **RealtimeSyncManager 클래스**
```javascript
class RealtimeSyncManager {
    // 데이터 변경 시 모든 UI 컴포넌트 업데이트
    static broadcastDataUpdate() {
        // 홈페이지 통계 업데이트
        this.updateHomeStatistics();
        
        // 문제 풀이 페이지 통계 업데이트
        this.updateQuestionPageStatistics();
        
        // 사이드바 통계 업데이트
        this.updateSidebarStatistics();
        
        // 이벤트 발생
        EventBus.emit('dataUpdated');
    }
    
    // 홈페이지 통계 업데이트
    static updateHomeStatistics() {
        const userId = getCurrentUserId();
        const stats = StatisticsManager.getUserStatistics(userId);
        
        // 홈페이지 통계 박스 업데이트
        const homeStats = document.querySelectorAll('.home-statistics');
        homeStats.forEach(element => {
            const statType = element.dataset.statType;
            switch (statType) {
                case 'totalQuestions':
                    element.textContent = stats.totalQuestionsAttempted;
                    break;
                case 'accuracy':
                    element.textContent = `${stats.accuracyRate}%`;
                    break;
                case 'studyDays':
                    element.textContent = stats.studyDays;
                    break;
            }
        });
    }
}
```

---

## 🎯 구현 우선순위

### **Phase 1: 기본 문제 풀이 (3주)**
1. **회차별 문제 풀이**: 기본 40문제 풀이 시스템
2. **정답 확인**: 간단한 정답 체크 및 결과 표시
3. **이어풀기**: 기본 진도 추적 및 복원
4. **모바일 UI**: 터치 친화적 인터페이스

### **Phase 2: 고급 기능 (2주)**
1. **과목별 필터링**: 중급 서비스용 과목별 문제 제공
2. **상세 통계**: 실시간 통계 업데이트 및 표시
3. **진위형 문제**: 고급 서비스용 진위형 문제 시스템

### **Phase 3: 최적화 (1주)**
1. **성능 최적화**: 빠른 문제 로딩 및 응답
2. **사용자 경험**: 부드러운 애니메이션 및 전환
3. **오프라인 지원**: 네트워크 없이도 기본 기능 동작

---

## 🧪 테스트 시나리오

### **1. 기본 문제 풀이 테스트**
```javascript
describe('Question Solving Tests', () => {
    test('문제 로딩 및 표시', () => {
        const manager = new QuestionSolvingManager();
        manager.startQuestionSolving(28);
        
        expect(manager.questions.length).toBe(40);
        expect(manager.currentQuestionIndex).toBe(0);
    });
    
    test('정답 확인 및 통계 업데이트', async () => {
        const manager = new QuestionSolvingManager();
        manager.startQuestionSolving(28);
        
        // 답안 선택
        manager.selectAnswer('A');
        
        // 정답 확인
        await manager.checkAnswer();
        
        // 통계 확인
        const stats = StatisticsManager.getUserStatistics(getCurrentUserId());
        expect(stats.totalQuestionsAttempted).toBe(1);
    });
});
```

### **2. 이어풀기 테스트**
```javascript
describe('Continue Learning Tests', () => {
    test('이어풀기 정보 저장 및 복원', () => {
        const userId = 'test_user';
        
        // 진도 업데이트
        ProgressManager.updateProgress(userId, {
            subject: '관계법령',
            questionNumber: 20,
            isCorrect: true
        });
        
        // 이어풀기 정보 조회
        const continueInfo = ProgressManager.getContinueLearningInfo(userId, '관계법령');
        expect(continueInfo.nextQuestionIndex).toBe(20);
    });
});
```

---

**작성자**: AI Assistant (Seo Daeri)  
**작성일**: 2024-12-19  
**기준**: ACIU S4 검증된 아키텍처 + GEP 요구사항
