# GEP V1.0 실용적 테스트 방법

## 📋 개요
**General Exam Platform (GEP) V1.0** - 실용적 테스트 방법 및 품질 보증 전략
**기준**: ACIU S4 검증된 테스트 경험 + 실용적 접근법
**목표**: 효율적이고 신뢰할 수 있는 테스트 시스템 구축

---

## 🎯 핵심 테스트 원칙

### **실용성 우선 원칙**
- **필요한 것만 테스트**: 핵심 기능과 비즈니스 로직에 집중
- **자동화 우선**: 반복적인 테스트는 자동화로 효율성 확보
- **빠른 피드백**: 테스트 결과를 빠르게 확인하여 개발 속도 향상
- **유지보수 용이**: 테스트 코드도 간결하고 이해하기 쉽게 작성

### **ACIU S4 검증된 테스트 패턴**
- **단위 테스트**: 핵심 함수와 서비스 로직 검증
- **통합 테스트**: 모듈 간 상호작용 검증
- **사용자 시나리오 테스트**: 실제 사용자 행동 기반 테스트
- **성능 테스트**: 응답 시간과 처리량 검증

---

## 🧪 테스트 전략

### **1. 테스트 피라미드**

#### **테스트 레벨별 비중**
```javascript
// 테스트 피라미드 구성
const testPyramid = {
    unit: {
        percentage: 70,    // 70% - 단위 테스트
        description: '개별 함수/클래스 테스트',
        executionTime: '빠름 (초 단위)',
        maintenance: '낮음',
        examples: [
            'QuestionService.getQuestionsByRound()',
            'AnswerService.checkAnswer()',
            'UserService.registerUser()'
        ]
    },
    
    integration: {
        percentage: 20,    // 20% - 통합 테스트
        description: '모듈 간 상호작용 테스트',
        executionTime: '보통 (분 단위)',
        maintenance: '보통',
        examples: [
            '사용자 등록 → 문제 풀이 → 통계 업데이트',
            '중앙 아키텍처 데이터 플로우',
            '데이터베이스 연동 테스트'
        ]
    },
    
    e2e: {
        percentage: 10,    // 10% - 종단 간 테스트
        description: '전체 시스템 플로우 테스트',
        executionTime: '느림 (분 단위)',
        maintenance: '높음',
        examples: [
            '게스트 사용자 전체 학습 플로우',
            '결제 프로세스 전체 플로우',
            '통계 리포트 생성 플로우'
        ]
    }
};
```

### **2. 테스트 우선순위**

#### **우선순위 매트릭스**
```javascript
class TestPriorityMatrix {
    // 테스트 우선순위 결정
    static determineTestPriority(feature) {
        const factors = {
            businessImpact: this.assessBusinessImpact(feature),
            complexity: this.assessComplexity(feature),
            frequency: this.assessUsageFrequency(feature),
            risk: this.assessRiskLevel(feature)
        };
        
        const priorityScore = this.calculatePriorityScore(factors);
        
        return {
            feature: feature,
            priority: this.getPriorityLevel(priorityScore),
            factors: factors,
            score: priorityScore,
            testStrategy: this.generateTestStrategy(feature, priorityScore)
        };
    }
    
    // 비즈니스 영향도 평가
    static assessBusinessImpact(feature) {
        const impactLevels = {
            'user-registration': 5,      // 사용자 등록 - 최고 중요도
            'question-solving': 5,       // 문제 풀이 - 최고 중요도
            'answer-checking': 5,        // 정답 체크 - 최고 중요도
            'statistics': 4,             // 통계 - 높은 중요도
            'continue-learning': 4,      // 이어풀기 - 높은 중요도
            'payment': 3,                // 결제 - 중간 중요도
            'advanced-analytics': 2      // 고급 분석 - 낮은 중요도
        };
        
        return impactLevels[feature] || 1;
    }
    
    // 복잡도 평가
    static assessComplexity(feature) {
        const complexityLevels = {
            'user-registration': 2,      // 간단한 등록 로직
            'question-solving': 3,       // 중간 복잡도
            'answer-checking': 2,        // 간단한 정답 체크
            'statistics': 4,             // 복잡한 통계 계산
            'continue-learning': 3,      // 중간 복잡도
            'payment': 5,                // 매우 복잡한 결제 로직
            'advanced-analytics': 5      // 매우 복잡한 분석 로직
        };
        
        return complexityLevels[feature] || 1;
    }
    
    // 우선순위 점수 계산
    static calculatePriorityScore(factors) {
        const weights = {
            businessImpact: 0.4,
            complexity: 0.3,
            frequency: 0.2,
            risk: 0.1
        };
        
        let score = 0;
        for (const [factor, weight] of Object.entries(weights)) {
            score += factors[factor] * weight;
        }
        
        return Math.round(score * 20); // 0-100 점수로 변환
    }
    
    // 테스트 전략 생성
    static generateTestStrategy(feature, priorityScore) {
        if (priorityScore >= 80) {
            return {
                unitTests: 'COMPREHENSIVE',    // 포괄적 단위 테스트
                integrationTests: 'FULL',      // 전체 통합 테스트
                e2eTests: 'CRITICAL_PATHS',    // 핵심 경로 E2E 테스트
                performanceTests: 'REQUIRED',  // 성능 테스트 필수
                coverage: '95% 이상'
            };
        } else if (priorityScore >= 60) {
            return {
                unitTests: 'STANDARD',         // 표준 단위 테스트
                integrationTests: 'PARTIAL',   // 부분 통합 테스트
                e2eTests: 'BASIC',             // 기본 E2E 테스트
                performanceTests: 'OPTIONAL',  // 성능 테스트 선택적
                coverage: '80% 이상'
            };
        } else {
            return {
                unitTests: 'MINIMAL',          // 최소 단위 테스트
                integrationTests: 'NONE',      // 통합 테스트 없음
                e2eTests: 'NONE',              // E2E 테스트 없음
                performanceTests: 'NONE',      // 성능 테스트 없음
                coverage: '60% 이상'
            };
        }
    }
}
```

---

## 🔧 단위 테스트

### **1. 핵심 서비스 테스트**

#### **QuestionService 테스트**
```javascript
describe('QuestionService Tests', () => {
    // 회차별 문제 제공 테스트
    test('getQuestionsByRound returns correct number of questions', () => {
        const questions = QuestionService.getQuestionsByRound(28);
        
        expect(questions.length).toBeLessThanOrEqual(40);
        expect(questions.every(q => q.EROUND === 28)).toBe(true);
        expect(questions.every(q => q.STATUS === 'active')).toBe(true);
    });
    
    // 과목별 문제 제공 테스트
    test('getQuestionsBySubject returns subject-specific questions', () => {
        const questions = QuestionService.getQuestionsBySubject('관계법령');
        
        expect(questions.length).toBeGreaterThan(0);
        expect(questions.every(q => q.LAYER1 === '관계법령')).toBe(true);
    });
    
    // 서비스 레벨 제한 테스트
    test('respects service level restrictions', () => {
        const freeUser = { serviceLevel: 'FREE' };
        const premiumUser = { serviceLevel: 'PREMIUM' };
        
        // FREE 사용자는 과목별 필터링 불가
        expect(() => {
            QuestionService.getQuestionsBySubject('관계법령', freeUser.id);
        }).toThrow('Service level not sufficient');
        
        // PREMIUM 사용자는 과목별 필터링 가능
        const questions = QuestionService.getQuestionsBySubject('관계법령', premiumUser.id);
        expect(questions.length).toBeGreaterThan(0);
    });
});
```

#### **AnswerService 테스트**
```javascript
describe('AnswerService Tests', () => {
    // 정답 체크 테스트
    test('checkAnswer correctly validates answers', () => {
        const question = {
            QCODE: 'Q001',
            ANSWER: 'A',
            QUESTION: '테스트 문제'
        };
        
        const correctResult = AnswerService.checkAnswer('Q001', 'A', 'user123');
        const incorrectResult = AnswerService.checkAnswer('Q001', 'B', 'user123');
        
        expect(correctResult.isCorrect).toBe(true);
        expect(correctResult.correctAnswer).toBe('A');
        expect(incorrectResult.isCorrect).toBe(false);
        expect(incorrectResult.correctAnswer).toBe('A');
    });
    
    // 중앙 아키텍처 연동 테스트
    test('triggers central architecture update', () => {
        const mockCentralManager = jest.spyOn(CentralDataManager, 'recordAnswer');
        
        AnswerService.checkAnswer('Q001', 'A', 'user123');
        
        expect(mockCentralManager).toHaveBeenCalledWith(
            expect.objectContaining({
                questionId: 'Q001',
                userAnswer: 'A',
                userId: 'user123'
            })
        );
    });
});
```

### **2. 유틸리티 함수 테스트**

#### **데이터 검증 테스트**
```javascript
describe('Validation Utils Tests', () => {
    // 사용자 입력 검증 테스트
    test('validateUserInput handles valid data', () => {
        const validUserData = {
            name: '홍길동',
            email: 'hong@example.com',
            examDate: '2024-06-15'
        };
        
        const result = ValidationUtils.validateUserInput(validUserData);
        expect(result.isValid).toBe(true);
        expect(result.errors).toHaveLength(0);
    });
    
    // 사용자 입력 검증 테스트 - 오류 케이스
    test('validateUserInput catches invalid data', () => {
        const invalidUserData = {
            name: 'A',  // 너무 짧은 이름
            email: 'invalid-email',  // 잘못된 이메일
            examDate: '2023-01-01'  // 과거 날짜
        };
        
        const result = ValidationUtils.validateUserInput(invalidUserData);
        expect(result.isValid).toBe(false);
        expect(result.errors).toHaveLength(3);
        expect(result.errors).toContain('이름은 2자 이상이어야 합니다.');
        expect(result.errors).toContain('올바른 이메일을 입력하세요.');
        expect(result.errors).toContain('시험일은 미래 날짜여야 합니다.');
    });
});
```

---

## 🔗 통합 테스트

### **1. 사용자 플로우 테스트**

#### **게스트 사용자 등록 플로우**
```javascript
describe('Guest User Registration Flow', () => {
    test('complete guest registration flow', async () => {
        // 1. 게스트 등록
        const guestUser = await GuestRegistrationService.registerAsGuest();
        
        expect(guestUser.isGuest).toBe(true);
        expect(guestUser.serviceLevel).toBe('FREE');
        expect(guestUser.registrationDate).toBeDefined();
        
        // 2. 통계 초기화 확인
        const stats = StatisticsInitializer.getUserStatistics(guestUser.id);
        expect(stats.basicStats.totalQuestionsAttempted).toBe(0);
        expect(stats.registrationDate).toBe(guestUser.registrationDate);
        
        // 3. 세션 생성 확인
        const session = SessionManager.getCurrentUser();
        expect(session.id).toBe(guestUser.id);
        
        // 4. 홈페이지 접근 가능 확인
        const homeData = await HomeService.getHomeData(guestUser.id);
        expect(homeData.userId).toBe(guestUser.id);
        expect(homeData.serviceLevel).toBe('FREE');
    });
});
```

#### **문제 풀이 플로우**
```javascript
describe('Question Solving Flow', () => {
    test('complete question solving flow', async () => {
        const userId = 'test_user';
        
        // 1. 문제 로드
        const questions = await QuestionService.getQuestionsByRound(28);
        const question = questions[0];
        
        expect(question).toBeDefined();
        expect(question.EROUND).toBe(28);
        
        // 2. 문제 풀이
        const startTime = Date.now();
        const result = await AnswerService.checkAnswer(
            question.QCODE, 
            'A', 
            userId
        );
        const responseTime = Date.now() - startTime;
        
        expect(result.isCorrect).toBeDefined();
        expect(result.correctAnswer).toBe(question.ANSWER);
        expect(responseTime).toBeLessThan(1000); // 1초 이내 응답
        
        // 3. 통계 업데이트 확인
        const updatedStats = StatisticsManager.getUserStatistics(userId);
        expect(updatedStats.basicStats.totalQuestionsAttempted).toBe(1);
        
        // 4. 진행률 업데이트 확인
        const progress = ProgressManager.getUserProgress(userId);
        expect(progress.completedQuestions).toContain(question.QCODE);
        
        // 5. 이어풀기 정보 업데이트 확인
        const continueInfo = ProgressManager.getContinueLearningInfo(userId);
        expect(continueInfo.nextQuestionIndex).toBe(1);
    });
});
```

### **2. 중앙 아키텍처 테스트**

#### **데이터 플로우 테스트**
```javascript
describe('Central Architecture Data Flow', () => {
    test('data flows through central architecture correctly', async () => {
        const userId = 'test_user';
        const questionId = 'Q001';
        
        // 1. 이벤트 발생
        const event = await EventDatabase.recordQuestionEvent({
            userId: userId,
            questionId: questionId,
            userAnswer: 'A',
            correctAnswer: 'A',
            isCorrect: true
        });
        
        expect(event.eventType).toBe('QUESTION_ATTEMPTED');
        expect(event.userId).toBe(userId);
        
        // 2. 중앙 아키텍처 처리 확인
        const mockCentralManager = jest.spyOn(CentralDataManager, 'processEvent');
        
        await CentralDataManager.processEvent(event);
        
        expect(mockCentralManager).toHaveBeenCalledWith(event);
        
        // 3. 모든 관련 데이터 업데이트 확인
        const userStats = StatisticsManager.getUserStatistics(userId);
        const questionStats = StatisticsManager.getQuestionStatistics(questionId);
        const progress = ProgressManager.getUserProgress(userId);
        
        expect(userStats.basicStats.totalQuestionsAttempted).toBe(1);
        expect(questionStats.attempts).toBe(1);
        expect(progress.completedQuestions).toContain(questionId);
    });
});
```

---

## 🌐 종단 간 테스트

### **1. 핵심 사용자 시나리오**

#### **게스트 사용자 전체 학습 플로우**
```javascript
describe('Guest User Complete Learning Flow', () => {
    test('guest user can complete full learning session', async () => {
        // 1. 앱 시작 및 게스트 등록
        await page.goto('http://localhost:3000');
        await page.click('#guest-register-btn');
        
        const guestId = await page.evaluate(() => {
            return localStorage.getItem('gep_current_user_id');
        });
        expect(guestId).toBeDefined();
        
        // 2. 회차 선택
        await page.click('#round-selector-28');
        await page.click('#start-learning-btn');
        
        // 3. 문제 풀이 (3문제)
        for (let i = 0; i < 3; i++) {
            // 문제 표시 확인
            const questionText = await page.textContent('#question-text');
            expect(questionText.length).toBeGreaterThan(10);
            
            // 답안 선택
            await page.click('#option-A');
            await page.click('#check-answer-btn');
            
            // 결과 확인
            const resultText = await page.textContent('#answer-result');
            expect(resultText).toContain('정답') || expect(resultText).toContain('오답');
            
            // 다음 문제로 이동
            await page.click('#next-question-btn');
        }
        
        // 4. 통계 확인
        await page.click('#statistics-btn');
        
        const totalQuestions = await page.textContent('#total-questions');
        const accuracy = await page.textContent('#accuracy-rate');
        
        expect(parseInt(totalQuestions)).toBe(3);
        expect(accuracy).toContain('%');
        
        // 5. 이어풀기 확인
        await page.click('#continue-learning-btn');
        
        const continueInfo = await page.textContent('#continue-info');
        expect(continueInfo).toContain('4번 문제부터');
    }, 30000); // 30초 타임아웃
});
```

#### **결제 프로세스 플로우**
```javascript
describe('Payment Process Flow', () => {
    test('user can upgrade to premium service', async () => {
        // 1. 로그인
        await page.goto('http://localhost:3000/login');
        await page.fill('#email', 'test@example.com');
        await page.fill('#password', 'password123');
        await page.click('#login-btn');
        
        // 2. 프리미엄 업그레이드 시도
        await page.click('#upgrade-to-premium-btn');
        
        // 3. 결제 정보 입력
        await page.fill('#card-number', '4242424242424242');
        await page.fill('#expiry-date', '12/25');
        await page.fill('#cvv', '123');
        await page.fill('#cardholder-name', 'Test User');
        
        // 4. 결제 실행
        await page.click('#process-payment-btn');
        
        // 5. 결제 성공 확인
        const successMessage = await page.textContent('#payment-success');
        expect(successMessage).toContain('결제가 완료되었습니다');
        
        // 6. 서비스 레벨 업그레이드 확인
        const serviceLevel = await page.textContent('#service-level');
        expect(serviceLevel).toContain('PREMIUM');
        
        // 7. 프리미엄 기능 접근 확인
        await page.click('#subject-filter-btn');
        const subjectFilter = await page.isVisible('#subject-filter-modal');
        expect(subjectFilter).toBe(true);
    }, 60000); // 60초 타임아웃
});
```

---

## ⚡ 성능 테스트

### **1. 응답 시간 테스트**

#### **API 응답 시간 테스트**
```javascript
describe('API Response Time Tests', () => {
    test('question loading response time', async () => {
        const startTime = Date.now();
        
        const response = await fetch('/api/questions/28');
        const questions = await response.json();
        
        const responseTime = Date.now() - startTime;
        
        expect(responseTime).toBeLessThan(500); // 500ms 이내
        expect(questions.length).toBeLessThanOrEqual(40);
    });
    
    test('statistics calculation response time', async () => {
        const userId = 'test_user';
        
        const startTime = Date.now();
        
        const response = await fetch(`/api/statistics/${userId}`);
        const stats = await response.json();
        
        const responseTime = Date.now() - startTime;
        
        expect(responseTime).toBeLessThan(1000); // 1초 이내
        expect(stats.userId).toBe(userId);
    });
});
```

### **2. 부하 테스트**

#### **동시 사용자 테스트**
```javascript
describe('Concurrent User Load Tests', () => {
    test('handles multiple concurrent users', async () => {
        const concurrentUsers = 10;
        const promises = [];
        
        for (let i = 0; i < concurrentUsers; i++) {
            promises.push(
                fetch('/api/questions/28')
                    .then(response => response.json())
                    .then(data => ({ userId: i, success: true, data }))
                    .catch(error => ({ userId: i, success: false, error }))
            );
        }
        
        const results = await Promise.all(promises);
        
        const successfulRequests = results.filter(r => r.success);
        const failedRequests = results.filter(r => !r.success);
        
        expect(successfulRequests.length).toBeGreaterThan(concurrentUsers * 0.9); // 90% 이상 성공
        expect(failedRequests.length).toBeLessThan(concurrentUsers * 0.1); // 10% 미만 실패
    });
});
```

---

## 🎯 테스트 자동화

### **1. CI/CD 파이프라인**

#### **자동화된 테스트 워크플로우**
```yaml
# .github/workflows/test.yml
name: Automated Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-cov
    
    - name: Run unit tests
      run: |
        pytest tests/unit/ --cov=src --cov-report=xml
    
    - name: Run integration tests
      run: |
        pytest tests/integration/ --cov=src --cov-report=xml
    
    - name: Check coverage
      run: |
        coverage report --fail-under=80
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
      with:
        file: ./coverage.xml
```

### **2. 테스트 결과 모니터링**

#### **테스트 대시보드**
```javascript
class TestDashboard {
    // 테스트 결과 대시보드 생성
    static generateTestDashboard() {
        return {
            summary: {
                totalTests: this.getTotalTestCount(),
                passedTests: this.getPassedTestCount(),
                failedTests: this.getFailedTestCount(),
                coverage: this.getCoveragePercentage(),
                lastRun: this.getLastTestRun()
            },
            
            trends: {
                testExecutionTime: this.getTestExecutionTimeTrend(),
                failureRate: this.getFailureRateTrend(),
                coverageTrend: this.getCoverageTrend()
            },
            
            failures: this.getRecentFailures(),
            recommendations: this.generateTestRecommendations()
        };
    }
    
    // 테스트 권장사항 생성
    static generateTestRecommendations() {
        const recommendations = [];
        
        const coverage = this.getCoveragePercentage();
        if (coverage < 80) {
            recommendations.push({
                type: 'INCREASE_COVERAGE',
                priority: 'HIGH',
                description: '테스트 커버리지를 80% 이상으로 높이세요.',
                target: '80%',
                current: `${coverage}%`
            });
        }
        
        const failureRate = this.getFailureRate();
        if (failureRate > 5) {
            recommendations.push({
                type: 'REDUCE_FAILURES',
                priority: 'HIGH',
                description: '테스트 실패율을 5% 이하로 낮추세요.',
                target: '5%',
                current: `${failureRate}%`
            });
        }
        
        return recommendations;
    }
}
```

---

## 🎯 구현 우선순위

### **Phase 1: 핵심 테스트 구축 (1주)**
1. **단위 테스트**: 핵심 서비스 및 유틸리티 함수 테스트
2. **통합 테스트**: 사용자 플로우 및 중앙 아키텍처 테스트
3. **테스트 자동화**: CI/CD 파이프라인 구축

### **Phase 2: 고급 테스트 (1주)**
1. **E2E 테스트**: 핵심 사용자 시나리오 테스트
2. **성능 테스트**: 응답 시간 및 부하 테스트
3. **테스트 모니터링**: 대시보드 및 알림 시스템

### **Phase 3: 최적화 및 확장 (1주)**
1. **테스트 최적화**: 실행 시간 단축 및 효율성 향상
2. **테스트 확장**: 새로운 기능에 대한 테스트 추가
3. **품질 보증**: 테스트 품질 및 신뢰성 향상

---

**작성자**: AI Assistant (Seo Daeri)  
**작성일**: 2024-12-19  
**기준**: ACIU S4 검증된 테스트 경험 + 실용적 접근법
