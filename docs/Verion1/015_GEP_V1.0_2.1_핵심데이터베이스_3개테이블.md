# GEP V1.0 - 2.1 핵심 데이터베이스 (3개 테이블)

## 📋 개요
**General Exam Platform (GEP) V1.0**의 핵심 데이터베이스 설계

### 🎯 설계 원칙
- **간결성**: 3개 핵심 테이블로 모든 기능 지원
- **확장성**: 미래 기능 추가 시 구조 변경 최소화
- **성능**: 빠른 조회 및 업데이트 최적화
- **호환성**: 기존 GEP_MASTER 데이터 활용

---

## 🗄️ 핵심 테이블 설계

### **1. 사용자 테이블 (USERS)**

#### 1.1 테이블 구조
```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    nickname VARCHAR(50),
    subscription_level ENUM('free', 'premium', 'pro') DEFAULT 'free',
    created_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_login DATETIME,
    is_active BOOLEAN DEFAULT TRUE,
    settings JSON,  -- 사용자 설정 (테마, 알림 등)
    INDEX idx_email (email),
    INDEX idx_subscription (subscription_level)
);
```

#### 1.2 필드 상세 설명
| 필드명 | 타입 | 설명 | 제약조건 |
|--------|------|------|----------|
| `id` | INT | 사용자 고유 ID | PRIMARY KEY, AUTO_INCREMENT |
| `email` | VARCHAR(100) | 이메일 주소 | UNIQUE, NOT NULL |
| `password_hash` | VARCHAR(255) | 암호화된 비밀번호 | NOT NULL |
| `nickname` | VARCHAR(50) | 사용자 닉네임 | NULL 허용 |
| `subscription_level` | ENUM | 서비스 레벨 | 'free', 'premium', 'pro' |
| `created_date` | DATETIME | 가입일시 | DEFAULT CURRENT_TIMESTAMP |
| `last_login` | DATETIME | 마지막 로그인 | NULL 허용 |
| `is_active` | BOOLEAN | 계정 활성화 상태 | DEFAULT TRUE |
| `settings` | JSON | 사용자 설정 | NULL 허용 |

#### 1.3 샘플 데이터
```sql
INSERT INTO users (email, password_hash, nickname, subscription_level) VALUES
('user1@example.com', '$2b$10$...', '학습자1', 'free'),
('user2@example.com', '$2b$10$...', '학습자2', 'premium'),
('user3@example.com', '$2b$10$...', '학습자3', 'pro');
```

### **2. 문제 테이블 (QUESTIONS)**

#### 2.1 테이블 구조
```sql
CREATE TABLE questions (
    qcode VARCHAR(20) PRIMARY KEY,  -- 기존 GEP_MASTER 활용
    etitle VARCHAR(50) NOT NULL,    -- 시험 종류 (보험중개사, 보험심사역 등)
    eround INT NOT NULL,            -- 회차
    layer1 VARCHAR(50) NOT NULL,    -- 대분류 (관계법령, 손보1부, 손보2부)
    layer2 VARCHAR(50),             -- 중분류 (향후 확장용)
    layer3 VARCHAR(50),             -- 소분류 (향후 확장용)
    qnum INT NOT NULL,              -- 문제 번호
    qtype ENUM('A', 'B') DEFAULT 'A', -- A: 기출문제, B: 진위형문제
    question TEXT NOT NULL,         -- 문제 내용
    answer VARCHAR(10) NOT NULL,    -- 정답 (A, B, C, D)
    difficulty INT DEFAULT 3,       -- 난이도 (1-5)
    created_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    modified_date DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    status ENUM('active', 'inactive') DEFAULT 'active',
    INDEX idx_etitle_eround (etitle, eround),
    INDEX idx_layer1 (layer1),
    INDEX idx_qtype (qtype),
    INDEX idx_difficulty (difficulty)
);
```

#### 2.2 필드 상세 설명
| 필드명 | 타입 | 설명 | 제약조건 |
|--------|------|------|----------|
| `qcode` | VARCHAR(20) | 문제 고유 코드 | PRIMARY KEY |
| `etitle` | VARCHAR(50) | 시험 종류 | NOT NULL |
| `eround` | INT | 회차 번호 | NOT NULL |
| `layer1` | VARCHAR(50) | 대분류 | NOT NULL |
| `layer2` | VARCHAR(50) | 중분류 | NULL 허용 |
| `layer3` | VARCHAR(50) | 소분류 | NULL 허용 |
| `qnum` | INT | 문제 번호 | NOT NULL |
| `qtype` | ENUM | 문제 타입 | 'A': 기출, 'B': 진위형 |
| `question` | TEXT | 문제 내용 | NOT NULL |
| `answer` | VARCHAR(10) | 정답 | NOT NULL |
| `difficulty` | INT | 난이도 | 1-5, DEFAULT 3 |
| `created_date` | DATETIME | 생성일시 | DEFAULT CURRENT_TIMESTAMP |
| `modified_date` | DATETIME | 수정일시 | AUTO UPDATE |
| `status` | ENUM | 상태 | 'active', 'inactive' |

#### 2.3 샘플 데이터
```sql
INSERT INTO questions (qcode, etitle, eround, layer1, qnum, question, answer) VALUES
('ABAA-01', '보험중개사', 26, '관계법령', 1, '보험업법상 보험안내자료에 기재할 수 없는 것은?①보험계약자에게 유리한 내용만을 골라 안내하거나 다른 보험회사 상품과 비교한 사항②보험약관으로 정하는 보장에 관한 사항③보험금 지급제한에 관한 사항④보험회사의 상호나 명칭 또는 보험설계사·보험대리점 또는 보험중개사의 이름·상호나 명칭', 'A'),
('ABAA-02', '보험중개사', 26, '관계법령', 2, '다음 중 보험업법상 보험중개사가 할 수 없는 행위는?①보험계약의 체결을 중개하는 행위②보험계약의 이행을 중개하는 행위③보험금의 지급을 중개하는 행위④보험계약의 해지를 중개하는 행위', 'C');
```

### **3. 활동 테이블 (USER_ACTIVITIES)**

#### 3.1 테이블 구조
```sql
CREATE TABLE user_activities (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    qcode VARCHAR(20) NOT NULL,
    user_answer VARCHAR(10) NOT NULL,
    is_correct BOOLEAN NOT NULL,
    time_spent INT,                 -- 문제 풀이 시간 (초)
    session_id VARCHAR(50),         -- 세션 ID
    created_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (qcode) REFERENCES questions(qcode) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_qcode (qcode),
    INDEX idx_created_date (created_date),
    INDEX idx_user_session (user_id, session_id)
);
```

#### 3.2 필드 상세 설명
| 필드명 | 타입 | 설명 | 제약조건 |
|--------|------|------|----------|
| `id` | BIGINT | 활동 고유 ID | PRIMARY KEY, AUTO_INCREMENT |
| `user_id` | INT | 사용자 ID | FOREIGN KEY |
| `qcode` | VARCHAR(20) | 문제 코드 | FOREIGN KEY |
| `user_answer` | VARCHAR(10) | 사용자 답안 | NOT NULL |
| `is_correct` | BOOLEAN | 정답 여부 | NOT NULL |
| `time_spent` | INT | 풀이 시간 (초) | NULL 허용 |
| `session_id` | VARCHAR(50) | 세션 ID | NULL 허용 |
| `created_date` | DATETIME | 활동 일시 | DEFAULT CURRENT_TIMESTAMP |

#### 3.3 샘플 데이터
```sql
INSERT INTO user_activities (user_id, qcode, user_answer, is_correct, time_spent, session_id) VALUES
(1, 'ABAA-01', 'A', TRUE, 45, 'session_001'),
(1, 'ABAA-02', 'B', FALSE, 60, 'session_001'),
(2, 'ABAA-01', 'A', TRUE, 30, 'session_002');
```

---

## 🔗 테이블 관계 및 제약조건

### **1. 외래키 관계**
```sql
-- 사용자 활동 → 사용자
ALTER TABLE user_activities 
ADD CONSTRAINT fk_user_activities_user 
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- 사용자 활동 → 문제
ALTER TABLE user_activities 
ADD CONSTRAINT fk_user_activities_question 
FOREIGN KEY (qcode) REFERENCES questions(qcode) ON DELETE CASCADE;
```

### **2. 인덱스 최적화**
```sql
-- 복합 인덱스 (자주 사용되는 조회 패턴)
CREATE INDEX idx_user_round_subject ON user_activities (user_id, qcode);
CREATE INDEX idx_question_round ON questions (etitle, eround, layer1);
CREATE INDEX idx_user_subscription ON users (subscription_level, is_active);
```

---

## 📊 데이터 마이그레이션 (기존 GEP_MASTER 활용)

### **1. 기존 데이터 변환**
```python
import pandas as pd
import sqlite3

def migrate_gep_master_to_database():
    """기존 GEP_MASTER.xlsx 데이터를 새로운 DB 구조로 마이그레이션"""
    
    # 기존 Excel 파일 읽기
    df = pd.read_excel('GEP_MASTER_V1.0.xlsx')
    
    # 데이터베이스 연결
    conn = sqlite3.connect('gep_database.db')
    
    # 문제 데이터 변환 및 삽입
    for _, row in df.iterrows():
        qcode = row['QCODE']
        etitle = row['ETITLE']
        eround = row['EROUND']
        layer1 = row['LAYER1']
        qnum = row['QNUM']
        question = row['QUESTION']
        answer = row['ANSWER']
        
        # SQL 삽입
        sql = """
        INSERT INTO questions (qcode, etitle, eround, layer1, qnum, question, answer)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        """
        conn.execute(sql, (qcode, etitle, eround, layer1, qnum, question, answer))
    
    conn.commit()
    conn.close()
```

### **2. 데이터 검증**
```python
def validate_migration():
    """마이그레이션 결과 검증"""
    
    conn = sqlite3.connect('gep_database.db')
    
    # 문제 수 확인
    question_count = conn.execute("SELECT COUNT(*) FROM questions").fetchone()[0]
    print(f"총 문제 수: {question_count}")
    
    # 회차별 문제 수 확인
    round_stats = conn.execute("""
        SELECT eround, COUNT(*) as count 
        FROM questions 
        GROUP BY eround 
        ORDER BY eround
    """).fetchall()
    
    for round_num, count in round_stats:
        print(f"{round_num}회: {count}문제")
    
    conn.close()
```

---

## 🔧 핵심 쿼리 패턴

### **1. 회차별 문제 조회**
```sql
-- 특정 회차의 모든 문제 조회
SELECT qcode, qnum, layer1, question, answer
FROM questions 
WHERE etitle = '보험중개사' AND eround = 26
ORDER BY layer1, qnum;
```

### **2. 사용자 통계 조회**
```sql
-- 사용자별 정답률 통계
SELECT 
    u.nickname,
    COUNT(ua.id) as total_questions,
    SUM(CASE WHEN ua.is_correct THEN 1 ELSE 0 END) as correct_answers,
    ROUND(
        SUM(CASE WHEN ua.is_correct THEN 1 ELSE 0 END) * 100.0 / COUNT(ua.id), 
        2
    ) as accuracy
FROM users u
LEFT JOIN user_activities ua ON u.id = ua.user_id
WHERE u.id = ?
GROUP BY u.id, u.nickname;
```

### **3. 과목별 통계 조회**
```sql
-- 사용자별 과목별 정답률
SELECT 
    q.layer1,
    COUNT(ua.id) as total_questions,
    SUM(CASE WHEN ua.is_correct THEN 1 ELSE 0 END) as correct_answers,
    ROUND(
        SUM(CASE WHEN ua.is_correct THEN 1 ELSE 0 END) * 100.0 / COUNT(ua.id), 
        2
    ) as accuracy
FROM user_activities ua
JOIN questions q ON ua.qcode = q.qcode
WHERE ua.user_id = ?
GROUP BY q.layer1
ORDER BY q.layer1;
```

### **4. 최근 학습 활동 조회**
```sql
-- 사용자 최근 학습 활동
SELECT 
    q.qnum,
    q.layer1,
    q.question,
    ua.user_answer,
    ua.is_correct,
    ua.created_date
FROM user_activities ua
JOIN questions q ON ua.qcode = q.qcode
WHERE ua.user_id = ?
ORDER BY ua.created_date DESC
LIMIT 10;
```

---

## 🚀 성능 최적화

### **1. 인덱스 전략**
```sql
-- 자주 사용되는 조회 패턴을 위한 인덱스
CREATE INDEX idx_questions_round_subject ON questions (etitle, eround, layer1, qnum);
CREATE INDEX idx_activities_user_date ON user_activities (user_id, created_date);
CREATE INDEX idx_activities_question ON user_activities (qcode, is_correct);
```

### **2. 파티셔닝 전략**
```sql
-- 대용량 데이터를 위한 파티셔닝 (향후 확장)
-- user_activities 테이블을 날짜별로 파티셔닝
ALTER TABLE user_activities 
PARTITION BY RANGE (YEAR(created_date)) (
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

### **3. 캐싱 전략**
```javascript
// Redis 캐싱 예시
const cacheUserStats = async (userId) => {
  const stats = await getUserStatistics(userId);
  await redis.setex(`user_stats:${userId}`, 3600, JSON.stringify(stats)); // 1시간 캐시
  return stats;
};

const getUserStatsWithCache = async (userId) => {
  const cached = await redis.get(`user_stats:${userId}`);
  if (cached) {
    return JSON.parse(cached);
  }
  return await cacheUserStats(userId);
};
```

---

## 📈 확장성 고려사항

### **1. 미래 기능 확장**
```sql
-- 향후 추가될 수 있는 필드들
ALTER TABLE questions ADD COLUMN tags JSON;  -- 문제 태그
ALTER TABLE questions ADD COLUMN explanation TEXT;  -- 해설
ALTER TABLE user_activities ADD COLUMN device_info JSON;  -- 디바이스 정보
```

### **2. 다중 시험 지원**
```sql
-- 다른 시험 추가 시
INSERT INTO questions (qcode, etitle, eround, layer1, qnum, question, answer) VALUES
('BBAA-01', '보험심사역', 15, '보험학', 1, '보험의 본질적 특성은?', 'A'),
('CCAA-01', '손해사정사', 20, '손해사정론', 1, '손해사정의 원칙은?', 'B');
```

---

## 🧪 테스트 데이터

### **1. 테스트 데이터 생성**
```python
def generate_test_data():
    """테스트용 데이터 생성"""
    
    # 테스트 사용자 생성
    test_users = [
        ('test1@example.com', 'free'),
        ('test2@example.com', 'premium'),
        ('test3@example.com', 'pro')
    ]
    
    # 테스트 활동 데이터 생성
    test_activities = [
        (1, 'ABAA-01', 'A', True, 45),
        (1, 'ABAA-02', 'B', False, 60),
        (2, 'ABAA-01', 'A', True, 30),
        (2, 'ABAA-02', 'A', True, 40)
    ]
    
    return test_users, test_activities
```

---

## 📊 성공 지표

### **1. 데이터베이스 성능**
- **조회 속도**: 문제 로딩 100ms 이내
- **동시 접속**: 100명 동시 접속 지원
- **데이터 무결성**: 외래키 제약조건 100% 준수

### **2. 확장성**
- **데이터 증가**: 10만 문제, 1만 사용자 지원
- **기능 확장**: 새로운 시험/과목 추가 용이
- **성능 유지**: 데이터 증가 시에도 성능 유지

---

## 🚀 다음 단계

### **데이터베이스 설계 완성 후**
1. **데이터 마이그레이션**: 기존 GEP_MASTER 데이터 변환
2. **API 개발**: 데이터베이스 접근 API 구현
3. **성능 테스트**: 실제 사용 시나리오 기반 성능 검증

---

**작성자**: AI Assistant (Seo Daeri)  
**작성일**: 2024-12-19  
**문서 번호**: 015_GEP_V1.0_2.1_핵심데이터베이스_3개테이블
