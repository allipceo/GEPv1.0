# GEP V1.0 í†µê³„ ë¶„ì„ ì„œë¹„ìŠ¤ ì„¤ê³„

## ğŸ“‹ ê°œìš”
**General Exam Platform (GEP) V1.0** - í†µê³„ ë¶„ì„ ì„œë¹„ìŠ¤ ì„¤ê³„
**ê¸°ì¤€**: ACIU S4 ê²€ì¦ëœ í†µê³„ ì‹œìŠ¤í…œ + GEP ìš”êµ¬ì‚¬í•­
**ëª©í‘œ**: ë“±ë¡ì‹œì  ê¸°ë°˜ì˜ ì •í™•í•˜ê³  ì‹¤ìš©ì ì¸ í†µê³„ ë¶„ì„ ì‹œìŠ¤í…œ

---

## ğŸ¯ í•µì‹¬ ì„¤ê³„ ì›ì¹™

### **ACIU S4 ê²€ì¦ëœ í†µê³„ ì‹œìŠ¤í…œ íŒ¨í„´ ì ìš©**
- **ë“±ë¡ì‹œì  ê¸°ë°˜ í†µê³„**: ëª¨ë“  í†µê³„ì˜ ì¶œë°œì ì€ ì‚¬ìš©ì ë“±ë¡ì¼
- **ë¬¸ì œí’€ì´ ì‹œì  ë°ì´í„° ìƒì„±**: ëª¨ë“  ë°ì´í„°ëŠ” ë¬¸ì œ í’€ì´ ìˆœê°„ì— ìƒì„±
- **ì¤‘ì•™ ì•„í‚¤í…ì²˜ ê¸°ë°˜**: ëª¨ë“  í†µê³„ ë°ì´í„°ëŠ” ì¤‘ì•™ì—ì„œ ê´€ë¦¬
- **ì´ë²¤íŠ¸ ë°ì´í„°ë² ì´ìŠ¤**: ë³„ë„ì˜ ì´ë²¤íŠ¸ DBë¡œ ëª¨ë“  í™œë™ ê¸°ë¡

### **GEP íŠ¹í™” ìš”êµ¬ì‚¬í•­**
- **ë²”ìš© í”Œë«í¼**: ë‹¤ì–‘í•œ ìê²©ì‹œí—˜ì— ì ìš© ê°€ëŠ¥í•œ í†µê³„ ì‹œìŠ¤í…œ
- **3ë‹¨ê³„ ì„œë¹„ìŠ¤ ë ˆë²¨**: FREE, PREMIUM, PROë³„ ì°¨ë³„í™”ëœ í†µê³„ ì œê³µ
- **ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸**: ë¬¸ì œ í’€ì´ ì¦‰ì‹œ ëª¨ë“  í†µê³„ ë°˜ì˜
- **í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°**: ìƒˆë¡œìš´ í†µê³„ ìœ í˜• ì‰½ê²Œ ì¶”ê°€

---

## ğŸ“Š í†µê³„ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### **1. í•µì‹¬ ë°ì´í„° í”Œë¡œìš°**

#### **í†µê³„ ë°ì´í„° ìƒì„± ë° íë¦„**
```
ì‚¬ìš©ì ë“±ë¡ â†’ í†µê³„ ë°ì´í„° ì´ˆê¸°í™” â†’ ë¬¸ì œ í’€ì´ â†’ 
ì´ë²¤íŠ¸ ë°ì´í„° ìƒì„± â†’ ì¤‘ì•™ ì•„í‚¤í…ì²˜ ì €ì¥ â†’ 
ë‹¤ì–‘í•œ í†µê³„ ê³„ì‚° â†’ UI ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
```

#### **ë“±ë¡ì‹œì  ê¸°ë°˜ í†µê³„ ì´ˆê¸°í™”**
```javascript
class StatisticsInitializer {
    // ì‚¬ìš©ì ë“±ë¡ ì‹œ í†µê³„ ë°ì´í„° ì´ˆê¸°í™”
    static initializeUserStatistics(userId, registrationDate) {
        const initialStatistics = {
            userId: userId,
            registrationDate: registrationDate,
            examDate: null,
            
            // ê¸°ë³¸ í†µê³„ ë°ì´í„°
            basicStats: {
                totalQuestionsAttempted: 0,
                totalCorrectAnswers: 0,
                accuracyRate: 0,
                studyDays: 0,
                lastStudyDate: null
            },
            
            // ì¼ë³„ í†µê³„ ë°ì´í„°
            dailyStats: {},
            
            // ê³¼ëª©ë³„ í†µê³„ ë°ì´í„°
            subjectStats: {
                'ê´€ê³„ë²•ë ¹': { attempted: 0, correct: 0, accuracy: 0 },
                'ì†ë³´1ë¶€': { attempted: 0, correct: 0, accuracy: 0 },
                'ì†ë³´2ë¶€': { attempted: 0, correct: 0, accuracy: 0 }
            },
            
            // ë¬¸ì œë³„ ìƒì„¸ í†µê³„
            questionStats: {},
            
            // í•™ìŠµ íŒ¨í„´ ë¶„ì„
            learningPatterns: {
                studyTimeDistribution: {},
                consecutiveCorrectAnswers: 0,
                longestStudySession: 0,
                averageStudyTime: 0
            },
            
            // ì˜ˆìƒ ì ìˆ˜ ë° í•©ê²© í™•ë¥ 
            predictions: {
                estimatedScore: 0,
                passProbability: 0,
                weakSubjects: [],
                recommendedFocus: []
            }
        };
        
        // LocalStorageì— ì €ì¥
        localStorage.setItem(`gep_user_${userId}_statistics`, JSON.stringify(initialStatistics));
        
        // ì¤‘ì•™ ì•„í‚¤í…ì²˜ì— ë“±ë¡
        CentralDataManager.registerUserStatistics(userId, initialStatistics);
        
        return initialStatistics;
    }
}
```

### **2. ì´ë²¤íŠ¸ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„**

#### **EventDatabase í´ë˜ìŠ¤**
```javascript
class EventDatabase {
    // ë¬¸ì œ í’€ì´ ì´ë²¤íŠ¸ ì €ì¥
    static recordQuestionEvent(eventData) {
        const event = {
            id: this.generateEventId(),
            userId: eventData.userId,
            eventType: 'QUESTION_ATTEMPTED',
            timestamp: new Date().toISOString(),
            
            // ë¬¸ì œ ì •ë³´
            questionId: eventData.questionId,
            questionType: eventData.questionType,
            subject: eventData.subject,
            roundNumber: eventData.roundNumber,
            
            // ì‚¬ìš©ì ì‘ë‹µ
            userAnswer: eventData.userAnswer,
            correctAnswer: eventData.correctAnswer,
            isCorrect: eventData.isCorrect,
            
            // ì‹œê°„ ì •ë³´
            responseTime: eventData.responseTime, // ë°€ë¦¬ì´ˆ
            sessionDuration: eventData.sessionDuration,
            
            // ëˆ„ì  ì •ë³´
            cumulativeAttempts: eventData.cumulativeAttempts,
            cumulativeCorrect: eventData.cumulativeCorrect,
            cumulativeAccuracy: eventData.cumulativeAccuracy,
            
            // ì»¨í…ìŠ¤íŠ¸ ì •ë³´
            studyMode: eventData.studyMode, // 'basic', 'subject', 'personalized'
            deviceInfo: eventData.deviceInfo,
            sessionId: eventData.sessionId
        };
        
        // ì´ë²¤íŠ¸ DBì— ì €ì¥
        this.saveEvent(event);
        
        // ì¤‘ì•™ ì•„í‚¤í…ì²˜ì— ì „ì†¡
        CentralDataManager.processEvent(event);
        
        return event;
    }
    
    // ì´ë²¤íŠ¸ ì¡°íšŒ (í†µê³„ ê³„ì‚°ìš©)
    static getEventsByUser(userId, filters = {}) {
        const events = this.loadUserEvents(userId);
        
        // í•„í„° ì ìš©
        let filteredEvents = events;
        
        if (filters.dateRange) {
            filteredEvents = filteredEvents.filter(event => 
                event.timestamp >= filters.dateRange.start &&
                event.timestamp <= filters.dateRange.end
            );
        }
        
        if (filters.subject) {
            filteredEvents = filteredEvents.filter(event => 
                event.subject === filters.subject
            );
        }
        
        if (filters.eventType) {
            filteredEvents = filteredEvents.filter(event => 
                event.eventType === filters.eventType
            );
        }
        
        return filteredEvents;
    }
    
    // í†µê³„ ê³„ì‚°ìš© ì´ë²¤íŠ¸ ì§‘ê³„
    static aggregateEvents(userId, aggregationType) {
        const events = this.getEventsByUser(userId);
        
        switch (aggregationType) {
            case 'daily':
                return this.aggregateByDay(events);
            case 'subject':
                return this.aggregateBySubject(events);
            case 'question':
                return this.aggregateByQuestion(events);
            case 'timeDistribution':
                return this.aggregateByTime(events);
            default:
                return events;
        }
    }
}
```

### **3. ì¤‘ì•™ ì•„í‚¤í…ì²˜ ê¸°ë°˜ í†µê³„ ê´€ë¦¬**

#### **CentralStatisticsManager í´ë˜ìŠ¤**
```javascript
class CentralStatisticsManager {
    // ë¬¸ì œ í’€ì´ ì´ë²¤íŠ¸ ì²˜ë¦¬
    static processQuestionEvent(event) {
        const userId = event.userId;
        
        // 1. ê¸°ë³¸ í†µê³„ ì—…ë°ì´íŠ¸
        this.updateBasicStatistics(userId, event);
        
        // 2. ì¼ë³„ í†µê³„ ì—…ë°ì´íŠ¸
        this.updateDailyStatistics(userId, event);
        
        // 3. ê³¼ëª©ë³„ í†µê³„ ì—…ë°ì´íŠ¸
        this.updateSubjectStatistics(userId, event);
        
        // 4. ë¬¸ì œë³„ í†µê³„ ì—…ë°ì´íŠ¸
        this.updateQuestionStatistics(userId, event);
        
        // 5. í•™ìŠµ íŒ¨í„´ ë¶„ì„
        this.updateLearningPatterns(userId, event);
        
        // 6. ì˜ˆìƒ ì ìˆ˜ ì¬ê³„ì‚°
        this.recalculatePredictions(userId);
        
        // 7. ì‹¤ì‹œê°„ UI ì—…ë°ì´íŠ¸
        this.broadcastStatisticsUpdate(userId);
    }
    
    // ê¸°ë³¸ í†µê³„ ì—…ë°ì´íŠ¸
    static updateBasicStatistics(userId, event) {
        const stats = this.getUserStatistics(userId);
        
        stats.basicStats.totalQuestionsAttempted++;
        if (event.isCorrect) {
            stats.basicStats.totalCorrectAnswers++;
        }
        
        stats.basicStats.accuracyRate = Math.round(
            (stats.basicStats.totalCorrectAnswers / stats.basicStats.totalQuestionsAttempted) * 100
        );
        
        // í•™ìŠµ ì¼ìˆ˜ ê³„ì‚°
        const registrationDate = new Date(stats.registrationDate);
        const today = new Date();
        const studyDays = Math.ceil((today - registrationDate) / (1000 * 60 * 60 * 24));
        stats.basicStats.studyDays = Math.max(1, studyDays);
        
        // ë§ˆì§€ë§‰ í•™ìŠµì¼ ì—…ë°ì´íŠ¸
        stats.basicStats.lastStudyDate = event.timestamp;
        
        this.saveUserStatistics(userId, stats);
    }
    
    // ì¼ë³„ í†µê³„ ì—…ë°ì´íŠ¸
    static updateDailyStatistics(userId, event) {
        const stats = this.getUserStatistics(userId);
        const eventDate = event.timestamp.split('T')[0];
        
        if (!stats.dailyStats[eventDate]) {
            stats.dailyStats[eventDate] = {
                questionsAttempted: 0,
                correctAnswers: 0,
                accuracy: 0,
                studyTime: 0,
                subjects: new Set()
            };
        }
        
        const dailyStats = stats.dailyStats[eventDate];
        dailyStats.questionsAttempted++;
        
        if (event.isCorrect) {
            dailyStats.correctAnswers++;
        }
        
        dailyStats.accuracy = Math.round(
            (dailyStats.correctAnswers / dailyStats.questionsAttempted) * 100
        );
        
        dailyStats.studyTime += event.responseTime || 0;
        dailyStats.subjects.add(event.subject);
        
        this.saveUserStatistics(userId, stats);
    }
    
    // ê³¼ëª©ë³„ í†µê³„ ì—…ë°ì´íŠ¸
    static updateSubjectStatistics(userId, event) {
        const stats = this.getUserStatistics(userId);
        const subject = event.subject;
        
        if (!stats.subjectStats[subject]) {
            stats.subjectStats[subject] = { attempted: 0, correct: 0, accuracy: 0 };
        }
        
        const subjectStats = stats.subjectStats[subject];
        subjectStats.attempted++;
        
        if (event.isCorrect) {
            subjectStats.correct++;
        }
        
        subjectStats.accuracy = Math.round(
            (subjectStats.correct / subjectStats.attempted) * 100
        );
        
        this.saveUserStatistics(userId, stats);
    }
    
    // ë¬¸ì œë³„ í†µê³„ ì—…ë°ì´íŠ¸
    static updateQuestionStatistics(userId, event) {
        const stats = this.getUserStatistics(userId);
        const questionId = event.questionId;
        
        if (!stats.questionStats[questionId]) {
            stats.questionStats[questionId] = {
                attempts: 0,
                correct: 0,
                accuracy: 0,
                averageResponseTime: 0,
                lastAttempted: null
            };
        }
        
        const questionStats = stats.questionStats[questionId];
        questionStats.attempts++;
        
        if (event.isCorrect) {
            questionStats.correct++;
        }
        
        questionStats.accuracy = Math.round(
            (questionStats.correct / questionStats.attempts) * 100
        );
        
        // í‰ê·  ì‘ë‹µ ì‹œê°„ ì—…ë°ì´íŠ¸
        const totalTime = questionStats.averageResponseTime * (questionStats.attempts - 1) + (event.responseTime || 0);
        questionStats.averageResponseTime = Math.round(totalTime / questionStats.attempts);
        
        questionStats.lastAttempted = event.timestamp;
        
        this.saveUserStatistics(userId, stats);
    }
}
```

---

## ğŸ“ˆ í†µê³„ ë¶„ì„ ì„œë¹„ìŠ¤

### **1. ê¸°ë³¸ í†µê³„ ì„œë¹„ìŠ¤ (FREE)**

#### **BasicStatisticsService í´ë˜ìŠ¤**
```javascript
class BasicStatisticsService {
    // í™ˆí˜ì´ì§€ ê¸°ë³¸ í†µê³„
    static getHomeStatistics(userId) {
        const stats = CentralStatisticsManager.getUserStatistics(userId);
        
        return {
            totalQuestions: stats.basicStats.totalQuestionsAttempted,
            accuracy: stats.basicStats.accuracyRate,
            studyDays: stats.basicStats.studyDays,
            todayQuestions: this.getTodayQuestions(userId),
            todayAccuracy: this.getTodayAccuracy(userId),
            dDay: this.calculateDDay(stats.examDate)
        };
    }
    
    // ì˜¤ëŠ˜ í•™ìŠµ í˜„í™©
    static getTodayStatistics(userId) {
        const today = new Date().toISOString().split('T')[0];
        const stats = CentralStatisticsManager.getUserStatistics(userId);
        const dailyStats = stats.dailyStats[today] || { questionsAttempted: 0, correctAnswers: 0, accuracy: 0 };
        
        return {
            questionsAttempted: dailyStats.questionsAttempted,
            correctAnswers: dailyStats.correctAnswers,
            accuracy: dailyStats.accuracy,
            studyTime: dailyStats.studyTime || 0
        };
    }
    
    // ê³¼ëª©ë³„ ê¸°ë³¸ í†µê³„
    static getSubjectStatistics(userId) {
        const stats = CentralStatisticsManager.getUserStatistics(userId);
        
        return Object.entries(stats.subjectStats).map(([subject, data]) => ({
            subject: subject,
            attempted: data.attempted,
            correct: data.correct,
            accuracy: data.accuracy,
            progress: this.calculateSubjectProgress(userId, subject)
        }));
    }
}
```

### **2. ê³ ê¸‰ í†µê³„ ì„œë¹„ìŠ¤ (PREMIUM)**

#### **AdvancedStatisticsService í´ë˜ìŠ¤**
```javascript
class AdvancedStatisticsService {
    // ìƒì„¸ í•™ìŠµ ë¶„ì„
    static getDetailedAnalysis(userId) {
        const events = EventDatabase.getEventsByUser(userId);
        
        return {
            timeDistribution: this.analyzeTimeDistribution(events),
            learningPatterns: this.analyzeLearningPatterns(events),
            weakPoints: this.identifyWeakPoints(userId),
            improvementTrends: this.analyzeImprovementTrends(events),
            studyEfficiency: this.calculateStudyEfficiency(events)
        };
    }
    
    // ì‹œê°„ëŒ€ë³„ í•™ìŠµ íŒ¨í„´ ë¶„ì„
    static analyzeTimeDistribution(events) {
        const timeSlots = {
            '06-09': 0, '09-12': 0, '12-15': 0, '15-18': 0,
            '18-21': 0, '21-24': 0, '00-03': 0, '03-06': 0
        };
        
        events.forEach(event => {
            const hour = new Date(event.timestamp).getHours();
            let timeSlot;
            
            if (hour >= 6 && hour < 9) timeSlot = '06-09';
            else if (hour >= 9 && hour < 12) timeSlot = '09-12';
            else if (hour >= 12 && hour < 15) timeSlot = '12-15';
            else if (hour >= 15 && hour < 18) timeSlot = '15-18';
            else if (hour >= 18 && hour < 21) timeSlot = '18-21';
            else if (hour >= 21 && hour < 24) timeSlot = '21-24';
            else if (hour >= 0 && hour < 3) timeSlot = '00-03';
            else timeSlot = '03-06';
            
            timeSlots[timeSlot]++;
        });
        
        return timeSlots;
    }
    
    // í•™ìŠµ íŒ¨í„´ ë¶„ì„
    static analyzeLearningPatterns(events) {
        const patterns = {
            consecutiveCorrect: 0,
            longestSession: 0,
            averageSessionLength: 0,
            preferredSubjects: [],
            studyIntensity: 'low' // low, medium, high
        };
        
        // ì—°ì† ì •ë‹µ ë¶„ì„
        let currentStreak = 0;
        let maxStreak = 0;
        
        events.forEach(event => {
            if (event.isCorrect) {
                currentStreak++;
                maxStreak = Math.max(maxStreak, currentStreak);
            } else {
                currentStreak = 0;
            }
        });
        
        patterns.consecutiveCorrect = maxStreak;
        
        // í•™ìŠµ ì„¸ì…˜ ë¶„ì„
        const sessions = this.groupIntoSessions(events);
        patterns.longestSession = Math.max(...sessions.map(s => s.length));
        patterns.averageSessionLength = Math.round(
            sessions.reduce((sum, session) => sum + session.length, 0) / sessions.length
        );
        
        return patterns;
    }
    
    // ì·¨ì•½ì  ì‹ë³„
    static identifyWeakPoints(userId) {
        const stats = CentralStatisticsManager.getUserStatistics(userId);
        const weakPoints = [];
        
        // ê³¼ëª©ë³„ ì·¨ì•½ì 
        Object.entries(stats.subjectStats).forEach(([subject, data]) => {
            if (data.accuracy < 60 && data.attempted >= 10) {
                weakPoints.push({
                    type: 'subject',
                    name: subject,
                    accuracy: data.accuracy,
                    attempts: data.attempted,
                    priority: 'high'
                });
            }
        });
        
        // ë¬¸ì œë³„ ì·¨ì•½ì 
        Object.entries(stats.questionStats).forEach(([questionId, data]) => {
            if (data.accuracy < 50 && data.attempts >= 3) {
                weakPoints.push({
                    type: 'question',
                    id: questionId,
                    accuracy: data.accuracy,
                    attempts: data.attempts,
                    priority: 'medium'
                });
            }
        });
        
        return weakPoints.sort((a, b) => {
            if (a.priority === 'high' && b.priority !== 'high') return -1;
            if (b.priority === 'high' && a.priority !== 'high') return 1;
            return b.accuracy - a.accuracy;
        });
    }
}
```

### **3. ì „ë¬¸ í†µê³„ ì„œë¹„ìŠ¤ (PRO)**

#### **ProfessionalStatisticsService í´ë˜ìŠ¤**
```javascript
class ProfessionalStatisticsService {
    // í•©ê²©ë¥  ì˜ˆì¸¡
    static predictPassProbability(userId) {
        const stats = CentralStatisticsManager.getUserStatistics(userId);
        const events = EventDatabase.getEventsByUser(userId);
        
        // ê¸°ë³¸ ì ìˆ˜ ê³„ì‚°
        const baseScore = this.calculateBaseScore(stats);
        
        // í•™ìŠµ íŒ¨í„´ ë³´ì •
        const patternBonus = this.calculatePatternBonus(events);
        
        // ì‹œê°„ ê´€ë¦¬ ë³´ì •
        const timeManagementBonus = this.calculateTimeManagementBonus(events);
        
        // ìµœì¢… ì˜ˆìƒ ì ìˆ˜
        const estimatedScore = Math.min(100, baseScore + patternBonus + timeManagementBonus);
        
        // í•©ê²© í™•ë¥  ê³„ì‚° (ê¸°ì¤€: 60ì  ì´ìƒ)
        const passProbability = this.calculatePassProbability(estimatedScore);
        
        return {
            estimatedScore: Math.round(estimatedScore),
            passProbability: Math.round(passProbability),
            confidence: this.calculateConfidence(stats),
            factors: {
                baseScore: Math.round(baseScore),
                patternBonus: Math.round(patternBonus),
                timeManagementBonus: Math.round(timeManagementBonus)
            }
        };
    }
    
    // ë§ì¶¤í˜• í•™ìŠµ ì¶”ì²œ
    static getPersonalizedRecommendations(userId) {
        const weakPoints = AdvancedStatisticsService.identifyWeakPoints(userId);
        const stats = CentralStatisticsManager.getUserStatistics(userId);
        const predictions = this.predictPassProbability(userId);
        
        const recommendations = [];
        
        // ì·¨ì•½ ê³¼ëª© ì§‘ì¤‘ í•™ìŠµ
        const weakSubjects = weakPoints.filter(w => w.type === 'subject');
        if (weakSubjects.length > 0) {
            recommendations.push({
                type: 'focus_subject',
                subject: weakSubjects[0].name,
                reason: `ì •ë‹µë¥  ${weakSubjects[0].accuracy}%ë¡œ ê°œì„  í•„ìš”`,
                priority: 'high',
                estimatedImprovement: this.estimateImprovement(weakSubjects[0])
            });
        }
        
        // ì˜¤ë‹µ ë¬¸ì œ ë°˜ë³µ í•™ìŠµ
        const weakQuestions = weakPoints.filter(w => w.type === 'question');
        if (weakQuestions.length > 0) {
            recommendations.push({
                type: 'review_questions',
                questionIds: weakQuestions.slice(0, 10).map(w => w.id),
                reason: 'ì •ë‹µë¥ ì´ ë‚®ì€ ë¬¸ì œë“¤ ë°˜ë³µ í•™ìŠµ',
                priority: 'medium',
                estimatedTime: weakQuestions.length * 2 // ë¬¸ì œë‹¹ 2ë¶„
            });
        }
        
        // í•™ìŠµ ì‹œê°„ ì¡°ì •
        const timeAnalysis = AdvancedStatisticsService.analyzeTimeDistribution(
            EventDatabase.getEventsByUser(userId)
        );
        const optimalTime = this.findOptimalStudyTime(timeAnalysis);
        
        if (optimalTime) {
            recommendations.push({
                type: 'adjust_schedule',
                optimalTime: optimalTime,
                reason: 'í•™ìŠµ íš¨ìœ¨ì´ ë†’ì€ ì‹œê°„ëŒ€ í™œìš©',
                priority: 'low',
                expectedBenefit: 'ì •ë‹µë¥  5-10% í–¥ìƒ ì˜ˆìƒ'
            });
        }
        
        return recommendations;
    }
    
    // ìƒì„¸ ì„±ê³¼ ë¶„ì„ ë¦¬í¬íŠ¸
    static generateDetailedReport(userId) {
        const stats = CentralStatisticsManager.getUserStatistics(userId);
        const events = EventDatabase.getEventsByUser(userId);
        const predictions = this.predictPassProbability(userId);
        const recommendations = this.getPersonalizedRecommendations(userId);
        
        return {
            summary: {
                totalStudyTime: this.calculateTotalStudyTime(events),
                averageDailyStudyTime: this.calculateAverageDailyStudyTime(events),
                totalQuestions: stats.basicStats.totalQuestionsAttempted,
                overallAccuracy: stats.basicStats.accuracyRate,
                studyDays: stats.basicStats.studyDays
            },
            
            trends: {
                weeklyProgress: this.calculateWeeklyProgress(events),
                accuracyTrend: this.calculateAccuracyTrend(events),
                studyIntensityTrend: this.calculateStudyIntensityTrend(events)
            },
            
            predictions: predictions,
            recommendations: recommendations,
            
            detailedAnalysis: {
                subjectBreakdown: this.getSubjectBreakdown(stats),
                timeAnalysis: AdvancedStatisticsService.analyzeTimeDistribution(events),
                learningPatterns: AdvancedStatisticsService.analyzeLearningPatterns(events),
                weakPoints: AdvancedStatisticsService.identifyWeakPoints(userId)
            }
        };
    }
}
```

---

## ğŸ”„ ì‹¤ì‹œê°„ í†µê³„ ì—…ë°ì´íŠ¸

### **1. ì‹¤ì‹œê°„ UI ì—…ë°ì´íŠ¸ ì‹œìŠ¤í…œ**

#### **RealtimeStatisticsUpdater í´ë˜ìŠ¤**
```javascript
class RealtimeStatisticsUpdater {
    // í†µê³„ ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    static broadcastStatisticsUpdate(userId) {
        const stats = CentralStatisticsManager.getUserStatistics(userId);
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        EventBus.emit('statisticsUpdated', {
            userId: userId,
            timestamp: new Date().toISOString(),
            statistics: stats
        });
        
        // ëª¨ë“  UI ì»´í¬ë„ŒíŠ¸ ì—…ë°ì´íŠ¸
        this.updateAllUIComponents(userId, stats);
    }
    
    // ëª¨ë“  UI ì»´í¬ë„ŒíŠ¸ ì—…ë°ì´íŠ¸
    static updateAllUIComponents(userId, stats) {
        // í™ˆí˜ì´ì§€ í†µê³„ ì—…ë°ì´íŠ¸
        this.updateHomeStatistics(stats);
        
        // ë¬¸ì œ í’€ì´ í˜ì´ì§€ í†µê³„ ì—…ë°ì´íŠ¸
        this.updateQuestionPageStatistics(stats);
        
        // í†µê³„ í˜ì´ì§€ ì—…ë°ì´íŠ¸
        this.updateStatisticsPage(stats);
        
        // ì‚¬ì´ë“œë°” í†µê³„ ì—…ë°ì´íŠ¸
        this.updateSidebarStatistics(stats);
    }
    
    // í™ˆí˜ì´ì§€ í†µê³„ ì—…ë°ì´íŠ¸
    static updateHomeStatistics(stats) {
        const homeStats = document.querySelectorAll('.home-statistics');
        
        homeStats.forEach(element => {
            const statType = element.dataset.statType;
            
            switch (statType) {
                case 'totalQuestions':
                    element.textContent = stats.basicStats.totalQuestionsAttempted;
                    break;
                case 'accuracy':
                    element.textContent = `${stats.basicStats.accuracyRate}%`;
                    break;
                case 'studyDays':
                    element.textContent = stats.basicStats.studyDays;
                    break;
                case 'todayQuestions':
                    const today = new Date().toISOString().split('T')[0];
                    const todayStats = stats.dailyStats[today] || { questionsAttempted: 0 };
                    element.textContent = todayStats.questionsAttempted;
                    break;
            }
        });
    }
    
    // ì§„í–‰ë¥  ë°” ì—…ë°ì´íŠ¸
    static updateProgressBars(stats) {
        const progressBars = document.querySelectorAll('.progress-bar');
        
        progressBars.forEach(bar => {
            const barType = bar.dataset.progressType;
            
            switch (barType) {
                case 'overall':
                    const overallProgress = Math.round((stats.basicStats.totalQuestionsAttempted / 789) * 100);
                    bar.style.width = `${overallProgress}%`;
                    bar.textContent = `${overallProgress}%`;
                    break;
                case 'subject':
                    const subject = bar.dataset.subject;
                    const subjectStats = stats.subjectStats[subject];
                    if (subjectStats) {
                        const subjectProgress = Math.round((subjectStats.attempted / 200) * 100); // ì˜ˆìƒ ë¬¸ì œ ìˆ˜
                        bar.style.width = `${subjectProgress}%`;
                        bar.textContent = `${subjectProgress}%`;
                    }
                    break;
            }
        });
    }
}
```

---

## ğŸ¯ êµ¬í˜„ ìš°ì„ ìˆœìœ„

### **Phase 1: ê¸°ë³¸ í†µê³„ ì‹œìŠ¤í…œ (3ì£¼)**
1. **ë“±ë¡ì‹œì  ê¸°ë°˜ í†µê³„ ì´ˆê¸°í™”**: ì‚¬ìš©ì ë“±ë¡ ì‹œ í†µê³„ ë°ì´í„° ìƒì„±
2. **ì´ë²¤íŠ¸ ë°ì´í„°ë² ì´ìŠ¤**: ë¬¸ì œ í’€ì´ ì´ë²¤íŠ¸ ì €ì¥ ì‹œìŠ¤í…œ
3. **ì¤‘ì•™ ì•„í‚¤í…ì²˜**: í†µê³„ ë°ì´í„° ì¤‘ì•™ ê´€ë¦¬ ì‹œìŠ¤í…œ
4. **ê¸°ë³¸ í†µê³„ ì„œë¹„ìŠ¤**: í™ˆí˜ì´ì§€ ê¸°ë³¸ í†µê³„ í‘œì‹œ

### **Phase 2: ê³ ê¸‰ í†µê³„ ì‹œìŠ¤í…œ (2ì£¼)**
1. **ìƒì„¸ ë¶„ì„ ê¸°ëŠ¥**: ì‹œê°„ëŒ€ë³„, íŒ¨í„´ë³„ ë¶„ì„
2. **ì·¨ì•½ì  ì‹ë³„**: ê³¼ëª©ë³„, ë¬¸ì œë³„ ì·¨ì•½ì  ë¶„ì„
3. **ê°œì„  íŠ¸ë Œë“œ**: í•™ìŠµ ì§„ë„ ë° ì •ë‹µë¥  íŠ¸ë Œë“œ ë¶„ì„
4. **ê³ ê¸‰ í†µê³„ UI**: ìƒì„¸ í†µê³„ í˜ì´ì§€ êµ¬í˜„

### **Phase 3: ì „ë¬¸ í†µê³„ ì‹œìŠ¤í…œ (2ì£¼)**
1. **í•©ê²©ë¥  ì˜ˆì¸¡**: AI ê¸°ë°˜ í•©ê²© í™•ë¥  ê³„ì‚°
2. **ë§ì¶¤í˜• ì¶”ì²œ**: ê°œì¸í™”ëœ í•™ìŠµ ì¶”ì²œ ì‹œìŠ¤í…œ
3. **ìƒì„¸ ë¦¬í¬íŠ¸**: ì¢…í•© ì„±ê³¼ ë¶„ì„ ë¦¬í¬íŠ¸
4. **ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸**: ëª¨ë“  í†µê³„ ì‹¤ì‹œê°„ ë™ê¸°í™”

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

### **1. ë“±ë¡ì‹œì  ê¸°ë°˜ í†µê³„ í…ŒìŠ¤íŠ¸**
```javascript
describe('Registration-based Statistics Tests', () => {
    test('í†µê³„ ì´ˆê¸°í™” ì‹œ ë“±ë¡ì¼ ê¸°ì¤€ ì„¤ì •', () => {
        const userId = 'test_user';
        const registrationDate = '2024-12-01';
        
        const stats = StatisticsInitializer.initializeUserStatistics(userId, registrationDate);
        
        expect(stats.registrationDate).toBe(registrationDate);
        expect(stats.basicStats.totalQuestionsAttempted).toBe(0);
        expect(stats.basicStats.studyDays).toBe(1);
    });
    
    test('ë¬¸ì œ í’€ì´ í›„ í†µê³„ ì •í™• ì—…ë°ì´íŠ¸', () => {
        const userId = 'test_user';
        const event = {
            userId: userId,
            questionId: 'Q001',
            isCorrect: true,
            timestamp: '2024-12-19T10:00:00Z'
        };
        
        CentralStatisticsManager.processQuestionEvent(event);
        const stats = CentralStatisticsManager.getUserStatistics(userId);
        
        expect(stats.basicStats.totalQuestionsAttempted).toBe(1);
        expect(stats.basicStats.totalCorrectAnswers).toBe(1);
        expect(stats.basicStats.accuracyRate).toBe(100);
    });
});
```

### **2. ì´ë²¤íŠ¸ ë°ì´í„°ë² ì´ìŠ¤ í…ŒìŠ¤íŠ¸**
```javascript
describe('Event Database Tests', () => {
    test('ë¬¸ì œ í’€ì´ ì´ë²¤íŠ¸ ì •í™• ì €ì¥', () => {
        const eventData = {
            userId: 'test_user',
            questionId: 'Q001',
            userAnswer: 'A',
            correctAnswer: 'A',
            isCorrect: true,
            responseTime: 5000
        };
        
        const event = EventDatabase.recordQuestionEvent(eventData);
        
        expect(event.eventType).toBe('QUESTION_ATTEMPTED');
        expect(event.isCorrect).toBe(true);
        expect(event.responseTime).toBe(5000);
    });
    
    test('ì´ë²¤íŠ¸ í•„í„°ë§ ë° ì§‘ê³„', () => {
        const userId = 'test_user';
        const filters = {
            dateRange: {
                start: '2024-12-01',
                end: '2024-12-31'
            },
            subject: 'ê´€ê³„ë²•ë ¹'
        };
        
        const events = EventDatabase.getEventsByUser(userId, filters);
        const aggregated = EventDatabase.aggregateEvents(userId, 'daily');
        
        expect(events.length).toBeGreaterThan(0);
        expect(aggregated).toBeDefined();
    });
});
```

---

**ì‘ì„±ì**: AI Assistant (Seo Daeri)  
**ì‘ì„±ì¼**: 2024-12-19  
**ê¸°ì¤€**: ACIU S4 ê²€ì¦ëœ í†µê³„ ì‹œìŠ¤í…œ + GEP ìš”êµ¬ì‚¬í•­
